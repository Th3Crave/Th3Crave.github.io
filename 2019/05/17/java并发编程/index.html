<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>java并发编程 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java并发编程</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕成锋的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 由来</i></a><a href="/MoonAndStar/"><i class="fa fa-heart"> MoonAndStar</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">java并发编程</h1><div class="post-meta">May 17, 2019<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><a class="disqus-comment-count" href="/2019/05/17/java并发编程/#vcomment"><span class="valine-comment-count" data-xid="/2019/05/17/java并发编程/"></span><span> 条评论</span></a><div class="post-content"><p>原子性<br>可见性<br>有序性</p>
<h3 id="1并方包"><a href="#1并方包" class="headerlink" title="1并方包"></a>1并方包</h3><p>Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic、Semaphore、CountDownLatch、ConcurrentHashMap、Executors</p>
<h3 id="2高可用高性能高并发"><a href="#2高可用高性能高并发" class="headerlink" title="2高可用高性能高并发"></a>2高可用高性能高并发</h3><h3 id="3并发与并行"><a href="#3并发与并行" class="headerlink" title="3并发与并行"></a>3并发与并行</h3><p>什么是并发、什么是并行<br>并发与并行的区别<br>操作系统层面：并行是两个或多个任务在同一时刻同时进行，需要多核CPU的支持；并发是两个或多个任务都请求运行，而处理器只能接受一个任务，就安排这几个任务轮流进行，宏观上是有多个任务在同时进行，实际上是因为CPU在不同的任务之间不停的切换，多个任务分时交替进行。并行是不抢占资源的，并发的多个任务之间是互相抢占资源的，只有多核CPU下才会并行执行。并发通常是提高运行在单处理器上的程序的性能。</p>
<h3 id="4什么是线程，与进程的区别"><a href="#4什么是线程，与进程的区别" class="headerlink" title="4什么是线程，与进程的区别"></a>4什么是线程，与进程的区别</h3><p>线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程<br>线程与进程的区别</p>
<p><strong>什么是线程</strong>：每个可以独立运行的程序都是一个进程，在一个进程中可以有多个执行单元同时运行，这些执行单元可以看作程序执行的一个个任务，被称为线程。操作系统中的每一个进程中至少存在一个线程，进程是资源分配的基本单元，线程是CPU调度的基本单位(在没有引入线程的时候，进程是资源分配和CPU调度的基本单位；引入进程是为了使多个程序能并发执行，提高资源利用率和系统吞吐量，引入线程是为了减少进程在并发执行时所付出的时空开销，线程切换比进程切换的开销要小，使操作系统具有更好的并发性。)<br><img src="/2019/05/17/java并发编程/进程和线程.png" alt=""><br>线程就是独立的执行路径。在程序运行时，即使没有自己创建线程，后台也会存在多个线程，如gc线程、主线程；mian()称为主线程，为系统的入口点，用于执行整个程序。<br>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的。对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制。线程会带来额外的开销，如cpu调度时间、并发控制开销。Java内存模型中，每个线程在自己的工作内存交互，加载和存储主内存控制不当会造成数据不一致。</p>
<p><strong>线程的实现</strong>：<br>1)内核支持线程(Kernel Supported Threads)<br>2)用户级线程(User Level Threads)<br>3)组合方式</p>
<p><strong>创建多线程的方式</strong>：<br>少用继承，多用实现。<br>1)继承Thread类，重写Thread类的run()方法，调用继承自Thead类的start()方法开启线程。<br><img src="/2019/05/17/java并发编程/thread.png" alt=""><br>2)实现Runnable接口，重写run()方法。通过new一个Thread(Runnable target)对象调用start()方法开启线程。<br><img src="/2019/05/17/java并发编程/runnable.png" alt=""><br>3)实现Callable接口，重写call()方法。(j.u.c并发包下，用的不多)<br><img src="/2019/05/17/java并发编程/callable.png" alt=""></p>
<p><strong>守护线程和用户线程</strong>：默认情况下，我们所创建的线程都是用户线程；被标记为守护线程的线程，程序不会等它执行完才停止，当所有的用户线程都执行完了程序就停止了，守护线程为用户线程服务。</p>
<p><strong>线程的状态</strong>：<br><img src="/2019/05/17/java并发编程/线程状态.png" alt=""><br><img src="/2019/05/17/java并发编程/线程状态2.png" alt=""><br><img src="/2019/05/17/java并发编程/线程状态转换.jpg" alt=""><br>新生状态：创建一个线程对象后，该线程对象就处于新建状态，此时它不能运行，和其他java对象一样，仅仅由java虚拟机为其分配了内存，没有表现出任何线程的动态特征。<br>就绪状态：当线程对象调用了start()方法后，该线程就进入就绪状态(也称可运行状态)。处于就绪状态的线程位于可运行池中，此时它只是具备了运行的条件，能否获得CPU的使用权开始运行，还需要等待系统的调度。<br>运行状态：如果处于就绪状态的线程获得了CPU的使用权，开始执行run()方法中的线程执行体，则该线程处于运行状态。当一个线程启动后，它不可能一直处于运行状态(除非它的线程执行体足够短，瞬间就结束了)，当使用完系统分配的时间后，系统就会剥夺该线程占用的CPU资源，让其他线程获得执行的机会。只有处于就绪状态的线程才会转换到运行状态。<br>死亡状态：线程的run()方法正常执行完毕或者线程抛出一个未捕获的异常Exception、错误Error，线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能再转换到其他状态。<br>阻塞状态：一个正在执行的线程在某些情况下，会放弃CPU的使用权，进入阻塞状态。线程进入阻塞状态后，就不能进入排队队列。只有当引起阻塞的原因被消除后，线程才可以转为就绪状态。</p>
<p><strong>线程停止</strong>：<br><img src="/2019/05/17/java并发编程/线程停止.png" alt=""></p>
<p><strong>线程休眠</strong>：<br>sleep()是静态/类方法，只能控制当前正在运行的线程休眠/阻塞，而不能控制其他线程休眠。当休眠时间结束后，线程就会返回到就绪状态，而不是立即开始运行。<br>sleep(long millis)指定当前正在执行的线程阻塞的毫秒数。<br>sleep()方法会抛出InterruptedException异常。<br>sleep时间达到后线程从阻塞状态进入就绪状态。<br>sleep可以模拟网络延时、倒计时等。<br>每一个对象都有一个锁，sleep不能释放锁。</p>
<p><strong>线程让步</strong>：<br>yield()方法让当前正在执行的线程暂停，不会阻塞该线程，而是将线程从运行状态转换成就绪状态，让CPU调度器重新调度一次。当某个线程调用yield()方法后，只有与当前线程优先级相同或者更高的线程才能获得执行的机会。</p>
<p><strong>线程插队</strong>：<br>join()方法，当在某个线程中调用其他线程的join()方法时，调用的线程将被阻塞，直到被join()方法加入的线程执行完成后她才会继续执行。</p>
<p><strong>线程的优先级</strong>：java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。线程调度器按照线程的优先级决定应调度哪个线程来执行。线程的优先级用数字表示范围从1到10。优先级的设定建议在start()调用前。程序在运行期间，处于就绪状态的每个线程都有自己的优先级，默认main线程具有普通优先级5。优先级越高的线程获得cpu执行的机会越大，不代表绝对的先后顺序。</p>
<h3 id="5线程池"><a href="#5线程池" class="headerlink" title="5线程池"></a>5线程池</h3><p>自己设计线程池、submit() 和 execute()、线程池原理<br>为什么不允许使用 Executors 创建线程池</p>
<h3 id="6线程安全"><a href="#6线程安全" class="headerlink" title="6线程安全"></a>6线程安全</h3><p>改(增加、删除、修改)数据时会有线程不安全现象，三大经典案例：售票、银行账户、对容器操作。这时需要进行并发控制，保证线程安全。</p>
<h4 id="6-1死锁"><a href="#6-1死锁" class="headerlink" title="6.1死锁"></a>6.1死锁</h4><h4 id="6-2死锁如何排查"><a href="#6-2死锁如何排查" class="headerlink" title="6.2死锁如何排查"></a>6.2死锁如何排查</h4><h4 id="6-3线程安全和内存模型的关系"><a href="#6-3线程安全和内存模型的关系" class="headerlink" title="6.3线程安全和内存模型的关系"></a>6.3线程安全和内存模型的关系</h4><h3 id="7锁"><a href="#7锁" class="headerlink" title="7锁"></a>7锁</h3><p>CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁</p>
<h3 id="8死锁"><a href="#8死锁" class="headerlink" title="8死锁"></a>8死锁</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>两个或多个线程各自抱着自己占有的资源，都不释放，都在等待对方的资源。<br>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时哟个有“两个以上对象的锁”时，就可能会发生“死锁”的问题。</p>
<h4 id="死锁如何解决"><a href="#死锁如何解决" class="headerlink" title="死锁如何解决"></a>死锁如何解决</h4><p>不要锁套锁，不要在同一个代码块中持有多个对象的锁。</p>
<h3 id="9-synchronized"><a href="#9-synchronized" class="headerlink" title="9 synchronized"></a>9 synchronized</h3><p>线程安全问题，其实就是由多个线程同时处理共享资源所导致的。解决线程安全问题要保证处理共享资源的代码在任何时刻只能有一个线程访问。Java中提供的同步机制，当多个线程使用同一个共享资源时，可以将处理共享资源的代码放置在一个代码块中，使用synchronized关键字来修饰，被称为同步代码块。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	操作共享资源代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，lock是一个锁对象，它是同步代码块的关键。当线程执行同步代码块时，首先会检查锁对象的标志位，默认情况下标志位为1，此时线程会执行同步代码块，同时将锁对象的标志位置为0。当一个新的线程执行到这段同步代码块时，由于锁对象的标志位为0，新线程会发生阻塞，等待当前线程执行完同步代码块后，锁对象的标志位被置为1，新线程才能进入同步代码块执行其中的代码。<br>使用synchronized关键字来修饰方法，被修饰的方法称为同步方法，在某一时刻只允许一个线程来访问，访问该方法的其他线程都会阻塞，直到当前线程访问完毕后，其他线程才有机会执行方法。</p>
<p><strong>同步代码块</strong>中的锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是唯一的，用共享资源作为锁对象(同步监视器)。“任意”说的是共享锁对象的类型。锁对象的创建代码不能放到run()方法中，否则每个线程运行到run()方法都会创建一个锁对象，这样每个线程都会有一个不同的锁，每个锁都有自己的标志位。<br><strong>同步成员方法</strong>也有自己的锁，它的锁就是当前调用该方法的对象，也就是this指向的对象。这样做的好处是，同步方法被所有线程所共享，方法所在的对象相对于所有线程来说是唯一的，从而保证了锁的唯一性。当一个线程执行该方法时，其他线程就不能进入该方法中，直到这个线程执行完这个方法为止，从而达到线程同步。<br><strong>Java中静态方法</strong>的锁是该方法所在的类的class对象，该对象可以用“类名.class”的方式获取。<br>同步解决了多个线程同时访问共享数据时的线程安全问题，只要加上一个锁，在同一时间内只能有一个线程执行，其它所有需要该锁的线程都被挂起。但是线程在执行同步代码时每次都要判断锁的状态，多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<h4 id="1-synchronized是如何实现的？"><a href="#1-synchronized是如何实现的？" class="headerlink" title="1.synchronized是如何实现的？"></a>1.synchronized是如何实现的？</h4><h4 id="2-synchronized和lock之间关系"><a href="#2-synchronized和lock之间关系" class="headerlink" title="2.synchronized和lock之间关系"></a>2.synchronized和lock之间关系</h4><p><img src="/2019/05/17/java并发编程/同步监视器-锁.png" alt=""></p>
<h4 id="3-不使用-synchronized-如何实现一个线程安全的单例"><a href="#3-不使用-synchronized-如何实现一个线程安全的单例" class="headerlink" title="3.不使用 synchronized 如何实现一个线程安全的单例"></a>3.不使用 synchronized 如何实现一个线程安全的单例</h4><h4 id="4-synchronized-和原子性、可见性和有序性之间的关系"><a href="#4-synchronized-和原子性、可见性和有序性之间的关系" class="headerlink" title="4.synchronized 和原子性、可见性和有序性之间的关系"></a>4.synchronized 和原子性、可见性和有序性之间的关系</h4><h3 id="10-volatile"><a href="#10-volatile" class="headerlink" title="10 volatile"></a>10 volatile</h3><h4 id="1-happens-before、内存屏障、编译器指令重排和-CPU-指令重"><a href="#1-happens-before、内存屏障、编译器指令重排和-CPU-指令重" class="headerlink" title="1.happens-before、内存屏障、编译器指令重排和 CPU 指令重"></a>1.happens-before、内存屏障、编译器指令重排和 CPU 指令重</h4><h4 id="2-volatile-的实现原理"><a href="#2-volatile-的实现原理" class="headerlink" title="2.volatile 的实现原理"></a>2.volatile 的实现原理</h4><h4 id="3-volatile-和原子性、可见性和有序性之间的关系"><a href="#3-volatile-和原子性、可见性和有序性之间的关系" class="headerlink" title="3.volatile 和原子性、可见性和有序性之间的关系"></a>3.volatile 和原子性、可见性和有序性之间的关系</h4><h4 id="4-有了-symchronized-为什么还需要-volatile"><a href="#4-有了-symchronized-为什么还需要-volatile" class="headerlink" title="4.有了 symchronized 为什么还需要 volatile"></a>4.有了 symchronized 为什么还需要 volatile</h4><p>在Object()类中提供了wait()、notify()、notifyAll()方法用于解决线程间的通信问题。任何类的实例对象都可以直接使用这些方法。</p>
<h4 id="11-sleep-和-wait"><a href="#11-sleep-和-wait" class="headerlink" title="11 sleep 和 wait"></a>11 sleep 和 wait</h4><h4 id="12-wait-和-notify"><a href="#12-wait-和-notify" class="headerlink" title="12 wait 和 notify"></a>12 wait 和 notify</h4><h4 id="13-notify-和-notifyAll"><a href="#13-notify-和-notifyAll" class="headerlink" title="13 notify 和 notifyAll"></a>13 notify 和 notifyAll</h4><p>wait()使当前线程放弃同步锁并进入等待，直到其他线程进入此同步锁，并调用notify()方法，或notifyAll()方法唤醒该线程为止。<br>notify()唤醒此同步锁上等待的第一个调用wait()方法的线程。<br>notifyAll()唤醒此同步锁上调用wait()方法的所有线程。<br>这三个方法的调用者都应该是同步锁对象，只能在同步方法或者同步代码块中使用，如果这三个方法的调用者不是同步锁对象，java虚拟机会抛出IllegalMonitorStateException异常。</p>
<h3 id="14-ThreadLocal"><a href="#14-ThreadLocal" class="headerlink" title="14 ThreadLocal"></a>14 ThreadLocal</h3><h3 id="15写一个死锁的程序"><a href="#15写一个死锁的程序" class="headerlink" title="15写一个死锁的程序"></a>15写一个死锁的程序</h3><p>死锁：两个线程都需要对方所占用的锁，也都无法释放自己所拥有的锁，于是这两个线程都处于了阻塞状态，互相等待。</p>
<h3 id="16写代码来解决生产者消费者问题"><a href="#16写代码来解决生产者消费者问题" class="headerlink" title="16写代码来解决生产者消费者问题"></a>16写代码来解决生产者消费者问题</h3><p><img src="/2019/05/17/java并发编程/生产者消费者.png" alt=""></p>
<h4 id="线程协作：生产者消费者模式"><a href="#线程协作：生产者消费者模式" class="headerlink" title="线程协作：生产者消费者模式"></a>线程协作：生产者消费者模式</h4><p>区别设计模式，设计模式是处理java设计的类与类之间的关系。<br>生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。<br>对于生产者，没有生产产品之前，要通知消费者等待；生产了产品之后，又需要马上通知消费者消费。<br>对于消费者，在消费之前，要通知生产者已经消费完，需要继续生产新产品以供消费。<br>在生产者消费者问题中，仅有synchronized是不够的。synchronized可阻止并发更新同一个共享资源，实现了同步；但不能用来实现不同线程之间的消息传递(通信)。<br><img src="/2019/05/17/java并发编程/生产者消费者解决1.png" alt=""><br><img src="/2019/05/17/java并发编程/生产者消费者解决2.png" alt=""></p>
<h3 id="17lambda表达式"><a href="#17lambda表达式" class="headerlink" title="17lambda表达式"></a>17lambda表达式</h3><p>避免匿名内部类定义过多，其实质属于函数式编程的概念。<br>lambda表达式简化简单线程(用一次)的使用</p>
<h3 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h3><p>某一个有规律的时间点干某件事<br>通过Timer和Timetask实现定时启动某个线程。<br>java.util.Timer：类似闹钟的功能，本身实现的就是一个线程。<br>java.util.TimerTask：一个抽象类，该类实现了Runnable接口，所以该类具有多线程的能力。</p>
</div><div class="tags"><a href="/tags/java基础/">java基础</a></div><div class="post-nav"><a class="pre" href="/2019/05/17/java基础知识/">java基础知识</a><a class="next" href="/2019/05/15/基于SpringBoot的校园商铺平台/">项目2.0 基于SpringBoot的校园商铺平台</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'6Cf3b4KjUDTblsuWBz4jJcdU-gzGzoHsz',
  appKey:'l6wP9udo8YARTJrXperWuWgE',
  placeholder:'我想听你说一句… （留言请填写您的昵称和邮箱，方便回复以邮件形式通知您）',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://blog.frozenwind.online"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/emotion/">emotion</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/java基础/" style="font-size: 15px;">java基础</a> <a href="/tags/java-web/" style="font-size: 15px;">java web</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/阿里云服务器/" style="font-size: 15px;">阿里云服务器</a> <a href="/tags/一言/" style="font-size: 15px;">一言</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/情书/" style="font-size: 15px;">情书</a> <a href="/tags/词/" style="font-size: 15px;">词</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/java虚拟机/" style="font-size: 15px;">java虚拟机</a> <a href="/tags/系统问题/" style="font-size: 15px;">系统问题</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/06/和小北说的999句话/">和小北说的999句话</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/29/数据结构与算法——树/">数据结构与算法——树</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/28/落寞诗人/">假如我是一个诗人</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/捞月亮的人/">捞月亮的人披着风</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/17/java网络编程/">java网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/17/java基础知识/">java基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/17/java并发编程/">java并发编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/15/基于SpringBoot的校园商铺平台/">项目2.0 基于SpringBoot的校园商铺平台</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/15/深入理解JVM——java与线程/">深入理解JVM——12.4java与线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/15/深入理解JVM——java内存模型/">深入理解JVM——12.3java内存模型</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.scarboroughcoral.top/" title="scarboroughcoral" target="_blank">scarboroughcoral</a><ul></ul><a href="http://blog.wangxuyao.club/" title="冰冰冰淇淋君icecream" target="_blank">冰冰冰淇淋君icecream</a><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" color="100,99,98" opacity="0.7" zindex="-1" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.3/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>