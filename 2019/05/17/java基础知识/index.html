<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>java基础知识 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java基础知识</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/MoonAndStar/"><i class="fa fa-heart"> MoonAndStar</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">java基础知识</h1><div class="post-meta">2019-05-17<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><a class="disqus-comment-count" href="/2019/05/17/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#vcomment"><span class="valine-comment-count" data-xid="/2019/05/17/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"></span><span> 条评论</span></a><div class="post-content"><h3 id="阅读源代码"><a href="#阅读源代码" class="headerlink" title="阅读源代码"></a>阅读源代码</h3><p>String、Integer、Long、Enum、<br>BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、<br>ArrayList &amp; LinkedList、<br>HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet<br><img src="/hashmap1.png"><br><img src="/hashmap2.png"></p>
<h4 id="谈一谈你对java的认识"><a href="#谈一谈你对java的认识" class="headerlink" title="谈一谈你对java的认识"></a>谈一谈你对java的认识</h4><p>首先java是一门面向对象的语言，所以它具有面向对象的特征，抽象、封装、继承、多态；其次，java是半编译半解释型的语言，因为有java虚拟机的存在，所有java语言具有跨平台性，一次编译到处运行；java语言与C和C++除了指针的区别之外，java还有着自动的垃圾回收机制；java支持多线程，支持泛型。</p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>8 种基本数据类型：整型、浮点型、布尔型、字符型<br>整型中 byte、short、int、long 的取值范围<br>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？ </p>
<h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>什么是包装类型、什么是基本类型、什么是自动拆装箱<br>装箱就是自动将基本数据类型的值转换为引用数据类型（将基本数据类型转换为包装器类型），拆箱就是将引用数据类型的对象转换为基本数据类型（自动将包装器类型转换为基本数据类型）。<br>装箱过程是通过调用包装器的valueOf方法实现，拆箱过程是通过调用包装器的xxxValue方法实现。（xxx代表基本数据类型）</p>
<p>Integer 的缓存机制<br>Integer的缓存机制： Integer是对小数据（-128<del>127）是有缓存的，在JVM初始化的时候，数据-128</del>127之间的数字便被缓存到了本地内存中，如果初始化-128~127之间的数字，会直接从内存中取出，不需要新建一个对象. <br>Byte、Short、Integer、Long 这四个整数类型包装类存在缓存区，缓存范围为-128-127<br>Character字符类型存在缓存区，缓存范围为0-127<br>Boolean布尔类型包装类存在缓存区，缓存范围为TRUE和FALSE<br>Float、Double这两个浮点数类型包装类没有缓存区,直接返回new Float(x)和new Double(x)</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串的不可变性<br>JDK 6 和 JDK 7 中 substring 的原理及区别、<br>replaceFirst、replaceAll、replace 区别、<br>String 对“+”的重载、字符串拼接的几种方式和区别<br>String.valueOf 和 Integer.toString 的区别、<br>switch 对 String 的支持<br>字符串池、常量池（运行时常量池、Class 常量池）、intern</p>
<h4 id="熟悉-Java-中各种关键字"><a href="#熟悉-Java-中各种关键字" class="headerlink" title="熟悉 Java 中各种关键字"></a>熟悉 Java 中各种关键字</h4><p>transient<br>instanceof<br>final<br>static<br>volatile<br>synchronized<br>const 原理及用法</p>
<h4 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h4><p>常用集合类的使用<br>Collection单列集合的父接口，Map双列集合的父接口<br>Collection下属两个接口List和Set。List中的元素有序(存入和取出的顺序一致)，并且允许重复元素，具体实现类有ArrayList、LinkedList和Vector。Set中的元素无序，不允许有重复元素，具体实现类有HashSet和TreeSet。</p>
<p>1.ArrayList 和 LinkedList 和 Vector 的区别<br>ArrayList底层结构是可以扩容的数组，具有按照数组下标索引访问的特性，查找操作快，添加删除元素慢，需要搬移元素；LinkedList的底层结构是双向循环链表，解决了ArrayList添加删除元素慢的不足；Vertor是线程安全的，线程安全，效率慢。</p>
<p>2.SynchronizedList 和 Vector 的区别</p>
<h4 id="3-HashMap、HashTable、ConcurrentHashMap区别"><a href="#3-HashMap、HashTable、ConcurrentHashMap区别" class="headerlink" title="3.HashMap、HashTable、ConcurrentHashMap区别"></a>3.HashMap、HashTable、ConcurrentHashMap区别</h4><p><img src="/qubie.png"><br>HashMap -&gt; java.util.HashMap<br>底层结构是散列表加链表，哈希值不同的元素散列到数组的相应位置，哈希值相同的元素以链表的结构存储。jdk1.8以后，阈值大于8(TREEIFY_THRESHOLD，树化)链表会进化成红黑树，阈值小于6(UNTREEIFY_THRESHOLD)红黑树会退化成链表。<br>向HashMap存储一个Key-Value，通过这个key进行hash函数转换(hashcode高低16位相异或)得到一个值，用得到的值对HashMap的散列表(数组)长度取模运算，得到在散列表中存储的下标索引，数组中的这个位置存放的是一个结点Node的引用。如果出现hash冲突，即通过key进行hash运算得出的值一样，就将第一个结点指向下一个结点，生成链表/红黑树。<br>getKey()时，通过key进行hash运算得到散列表下标索引，直接去该位置查找O(1)。</p>
<p>HashTable -&gt; java.util.HashTable<br>与HashMap相似，但是HashTable是线程安全的，效率慢。<br>如何优化HashTable？通过锁细粒度化，将整锁拆解成多个锁进行优化。</p>
<p>ConcurrentHashMap -&gt; java.util.concurrent<br><img src="/ConcurrentHashMap-put.png"><br>ConcurrentHashMap实现与HashMap一致，只不过支持多线程。<br>早期的ConcurrentHashMap：通过分段锁Segment来实现<br>jdk1.8之后，ConcurrentHashMap取消分段锁，采用CAS和synchronized来保证并发安全，使锁更细化。<br><img src="/ConcurrentHashMap-suo.png"><br>private transient volatile int sizeCtl;<br>volatile多线程之间的可见性，一个线程对volatile修饰的变量进行的改动，其他线程可以立即看到。</p>
<p>HashMap扩容问题：多线程环境下，调整大小会存在条件竞争，容易造成死锁；rehashing是一个比较耗时的过程。<br>HashMap延迟创建，在用到的时候才会创建。</p>
<p>4.Set 和 List 区别？Set 如何保证元素不重复？<br>HashSet的底层是HashMap。HashSet在add()一个元素时，会先获取这个元素的hashCode()，通过这个hashCode计算出这个元素要存储空间的地址，看这个地址上是否已经存储了元素，如果没有就存放进去，如果已经有元素存在，就用equals()方法，看已存在的元素与要存储的元素是否相等，如果相等就舍弃要存储的这个元素，如果不相等，就将要存储的元素存入。HashSet利用hashCode来访问，存取和查找性能快，按照hashCode来访问元素，存取顺序不一致。<br>TreeSet内部采用自平衡的二叉排序树来存储元素，在保证元素不重复的同时，还对元素进行排序。自然排序，让对象所属的类去实现comparable接口，无参构造；比较器接口comparator，有参构造。排序的顺序与存入元素的顺序可能不一致。</p>
<p>4.Java 8 中 stream 相关用法<br>5.apache 集合处理工具类的使用<br>6.不同版本的 JDK 中 HashMap 的实现的区别以及原因<br>7.Collection 和 Collections 区别<br>Collection是单列集合的父接口，Collections是jdk提供的一个操作集合的工具类。<br>8.Arrays.asList 获得的 List 使用时需要注意什么<br>9.Enumeration 和 Iterator 区别<br>10.fail-fast 和 fail-safe<br>11.CopyOnWriteArrayList、ConcurrentSkipListMap<br>12 J.U.C知识点梳理<br>java.util.concurrent提供了并发编程的解决方案<br>CAS是java.util.concurrent.atomic包的基础<br>AQS是java.util.concurrent.locks包以及一些常用类比如Semophore，ReentrantLock等类的基础<br>J.U.C包的分类：线程执行器executor，锁locks，原子变量类atomic，并发工具类tools，并发集合collections<br>并发工具类：闭锁CountDownLatch(让主线程等待一组事件发生后继续执行，事件指的是CountDownLatch里的countDown()方法)；栅栏CyclicBarrier(阻塞当前线程，等待其他线程)；信号量Semaphore(控制某个资源可被同时访问的线程个数)；交换器Exchanger(两个线程到达同步点后，相互交换数据)。<br>BlockingQueue：提供可阻塞的入队和出队操作</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举的用法、枚举的实现、枚举与单例、Enum 类<br>Java 枚举如何比较<br>switch 对枚举的支持<br>枚举的序列化如何实现<br>枚举的线程安全性问题</p>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>字符流、字节流、输入流、输出流、<br>同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型<br>BIO、java4-NIO 和 java7-AIO 的区别、三种 IO 的用法与原理、netty<br><img src="/BIO.png"><br><img src="/NIO.png"><br><img src="/NIO-%E7%B1%BB%E5%9E%8B.png"><br><img src="/AIO.png"></p>
<h4 id="反射-reflection"><a href="#反射-reflection" class="headerlink" title="反射 reflection"></a>反射 reflection</h4><p>反射与工厂模式、反射有什么用<br>Class 类、java.lang.reflect.*</p>
<p>Class.forName(classNmae)和ClassLoader.loadClass(className)<br>Class.forName(className)方法，内部实际调用的方法是Class.forName(className,true,classloader);第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。<br>ClassLoader.loadClass(className)方法，内部实际调用的方法是ClassLoader.loadClass(className,false);第2个boolean参数，表示目标对象是否进行链接，false表示不进行链接，不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行。</p>
<p>setAccessible()：启用和禁用访问安全检查的开关<br>值为true则指示反射的对象在使用时应该取消java语言访问检查；值为false则指示反射的对象应该实施java语言访问检查。并不是为true就能访问false就不能访问。<br>禁止安全检查可以提高反射的运行速度。</p>
<p>1)Class c = Class.forName(“org.feng.test.reflection”)<br>2)Class c = “org.feng.test.reflection”.getClass();<br>3)Class c = String.class; Class intClass = int.class;</p>
<p>java.lang.Class类，用来表示java中类型(class/interface/enum/annotation/primitive type/void)本身。<br>Class类的对象包含了某个被加载类的结构。一个被加载的类对应一个Class对象。<br>当一个class被加载，或当加载器(class loader)的defineClass()被JVN调用，JVM便自动产生一个Class对象。<br>Class类是Reflection的根源。针对任何你想动态加载、运行的类，唯有先获得相应的Class对象。</p>
<p>反射：在运行时加载、探知、使用编译期间完全未知的类。<br>程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。<br>Class c = Class.forName(“org.feng.test.reflection”)<br>加载完类之后，在堆内存中，就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了完整的类的结构信息。我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过这个镜子看到类的结构。<br>每一个java类都有属性和方法，每个对象(类的实例)表示或封装一些数据。虚拟机加载一个类，也需要一个对象来封装对应该类的结构信息，这个对象就是对应该类的Class对象，一个类只有一个Class对象。</p>
<p>反射的作用：动态加载类、动态获取类的信息(属性、方法、构造器)；动态构造对象；动态调用类和对象的方法；动态操作属性；获取泛型信息；处理注解。</p>
<h4 id="java字节码-bytecode"><a href="#java字节码-bytecode" class="headerlink" title="java字节码 bytecode"></a>java字节码 bytecode</h4><p>java动态性的两种常见实现方式：字节码操作和反射<br>运行时操作字节码可以：动态生成新的类；动态改变某个类的结构(添加/删除/修改新的属性和方法)<br>常见的字节码操作类库：BCEL(Byte Code Engineering Library)；ASM，轻量级java字节码操作框架，直接涉及到JVM底层的操作和指令；CGLIB(Code Generation Library)；Javassist。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>静态代理、动态代理<br>动态代理和反射的关系<br>动态代理的几种实现方式<br>AOP</p>
<p><strong>静态代理</strong>：具体类、代理类、共同接口。代理类和具体类都实现了共同接口，静态代理类只能为特定的接口服务，每个代理类只能为一个接口服务，如想要为多个接口服务则需要建立很多个代理类。<br>一个代理只能代理一种类型，而且是在编译期间就已经确定被代理的对象；而动态代理是在运行时，通过反射机制实现的，而且能够代理各种类型的对象。<br><strong>动态代理</strong>：<br>java.lang.reflect.Proxy：该类用于动态生成代理类，只需传入目标接口、目标接口的类加载器以及InvocationHandler便可为目标接口生成代理类及代理对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 方法 1: 该方法用于获取指定代理对象所关联的InvocationHandler</span><br><span class="line">static InvocationHandler getInvocationHandler(Object proxy) </span><br><span class="line"></span><br><span class="line">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</span><br><span class="line">static Class getProxyClass(ClassLoader loader, Class[] interfaces) </span><br><span class="line"></span><br><span class="line">// 方法 3：该方法用于判断指定类是否是一个动态代理类</span><br><span class="line">static boolean isProxyClass(Class cl) </span><br><span class="line"></span><br><span class="line">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span><br><span class="line">static Object newProxyInstance(ClassLoader loader, Class[] interfaces, </span><br><span class="line">    InvocationHandler h)</span><br></pre></td></tr></table></figure>
<p>java.lang.reflect.InvocationHandler：该接口包含一个invoke方法，通过该方法实现对委托类的代理的访问，是代理类完整逻辑的集中体现，包括要切入的增强逻辑和进行反射执行的真实业务逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 该方法代理类完整逻辑的集中体现。第一个参数既是代理类实例，第二个参数是被调用的方法对象，</span><br><span class="line">// 第三个方法是调用参数。通常通过反射完成对具体角色业务逻辑的调用，并对其进行增强。</span><br><span class="line">Object invoke(Object proxy, Method method, Object[] args)</span><br></pre></td></tr></table></figure>
<p>java.lang.ClassLoader：类加载器类，负责将类的字节码装载到Java虚拟机中并为其定义类对象，然后该类才能被使用。Proxy静态方法生成动态代理类同样需要通过类加载器来进行加载才能使用，它与普通类的唯一区别就是其字节码是由JVM在运行时动态生成的而非预存在于任何一个.class 文件中。<br>JDK动态代理的一般步骤如下：创建被代理的接口和类；实现InvocationHandler接口，对目标接口中声明的所有方法进行统一处理；调用Proxy的静态方法，创建代理类并生成相应的代理对象；使用代理。<br>小结：<br>　　1、实现动态代理的关键技术是反射；<br>　　2、代理对象是对目标对象的增强，以便对消息进行预处理和后处理；<br>　　3、InvocationHandler中的invoke()方法是代理类完整逻辑的集中体现，包括要切入的增强逻辑和进行反射执行的真实业务逻辑；<br>　　4、使用JDK动态代理机制为某一真实业务对象生成代理，只需要指定目标接口、目标接口的类加载器以及具体的InvocationHandler即可。<br>　　5、JDK动态代理的典型应用包括但不仅限于AOP、RPC、Struts2、Spring等重要经典框架。</p>
<p>OOP面向对象编程<br>AOP(Aspect Oriented Programming)面向切面编程<br>面向对象中最基本的单位是类、实例，面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务(例如审计auditing和事务transaction管理)进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑，它们并不负责其他的系统级关注点，例如日志或事务支持。<br>AOP通过代理模式来分离系统的业务逻辑和系统服务(日志、安全等)。<br>在日常的软件开发中，拿日志来说，一个系统软件的开发都是必须进行日志记录的，不然万一系统出现什么bug，都不知道哪里出了问题。举个例子，当开发一个登录功能，可能需要在用户登录前后进行权限校验并将校验信息(用户名、密码、请求登录时间、ip地址等)记录在日志文件中，当用户登陆进来之后，访问某个其他功能时，也需要进行合法性检查。如果系统非常庞大，系统中专门进行权限验证的代码是非常多的，也非常散乱，我们就想能不能将这些权限校验、日志记录等非业务逻辑功能的部分独立拆分开，并且在系统运行时需要的地方(连接点)进行动态插入运行，不需要的时候就不理。<br>AOP思想的实现基于代理模式，在java中一般采用JDK动态代理模式，但是JDK动态代理模式只能代理接口，如果要代理类就不行了。<br>因此，SpringAOP会这样子来进行切换，因为SpringAOP同时支持CGLIB、ASPECTJ、JDK动态代理，当你的真实对象有实现接口时，SpringAOP会默认采用JDK动态代理，否则采用CGLIB代理。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>元注解、自定义注解、Java 中常用注解使用、注解与反射的结合<br>Spring 常用注解</p>
<p>Annotation注解是从JDK5.0开始引入的。 comment注释<br>Annotation的作用：不是程序本身，可以对程序做出解释；可以被其他程序(比如编译器等)读取。(注解信息处理流程，是注解和注释的重大区别，如果没有注解信息处理流程，则注解毫无意义)<br>Annotation在哪里使用？可以附加在package，class，method，field的上面，parameter的前面，相当于给它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。</p>
<p>常见内置注解(jdk自带)：@Override，@Deprecated(不建议使用的方法，被此注解修饰的方法会带一个中划线)，@SuppressWarnings(定义在java.lang.SuppressWarnings，用来抑制编译时的警告信息)</p>
<p>元注解：注解的注解。元数据：数据的数据。<br>java定义了4个标准的meta-annotation类型，它们被用来提供对其它annotation类型作说明：@Target、@Retention、@Documented、@Inherited。<br>@Target：用于描述注解的使用范围(即被描述的注解可以用在什么地方)<br>@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期。注解的保留策略，RetentionPolicv.SOURCE在源文件中有效，RetentionPolicv.CLASS在class文件中有效，RetentionPolicv.RUNTIME在运行时有效，为RUNTIME可以被反射机制读取。</p>
<p>自定义注解：使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口<br>@interface用来声明一个注解，格式为：public @interface 注解名{定义体}<br>其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称；返回值类型就是参数的类型(返回值类型只能是基本类型、Class、String、enum)；可以通过default来声明参数的默认值；如果只有一个参数成员，一般参数名为value。</p>
<h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><p>java6.0引入动态编译机制<br>动态编译的两种做法：通过Runtime调用javac，启动新的进程取操作，Runtime run = Runtime.getRuntime(); Process process = run.exec(“javac -cp .java的路径”);通过JavaCompiler动态编译。<br><img src="/%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91.png"><br><img src="/%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84%E7%B1%BB.png"></p>
<h4 id="java脚本引擎"><a href="#java脚本引擎" class="headerlink" title="java脚本引擎"></a>java脚本引擎</h4><p>java脚本引擎是从jdk6.0之后添加的新功能。<br>脚本引擎,使得javay应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在java平台上调用各种脚本语言的目的；java脚本api是联通java平台和脚本语言的桥梁；可以把一些复杂异变的业务逻辑交给脚本语言处理，提高开发效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//获得脚本引擎对象</span><br><span class="line">ScriptEngineManager sem = new ScriptEngineManager();</span><br><span class="line">ScriptEngine engine = sem.getEngineByName(&quot;javascript&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="/%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.png"></p>
<h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><p>什么是 Java 消息服务、JMS 消息传送模型</p>
<h4 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h4><p>java.lang.management.<em>、 javax.management.</em></p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法<br>限定通配符和非限定通配符、上下界限定符 extends 和 super<br>List<Object> 和原始类型 List 之间的区别?<br>List&lt;?&gt; 和 List<Object> 之间的区别是什么?</p>
<p>java采用泛型擦除的机制来引入泛型。java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦，但是一旦编译完成，所有的和泛型有关的类型全部擦除。<br>为了通过反射操作这些类型以迎合实际开发的需要，java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能归一到Class类中的类型但是又和原始类型齐名的类型。<br>ParameterizedType：表示一种参数化的类型，比如Collection<String><br>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型<br>TypeVariable：各种类型变量的公共父接口<br>WildcardType(wildcard通配符)：代表一种通配符类型表达式，比如？，？ extends Number，？ super Integer</p>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>junit、mock、mockito、内存数据库（h2）</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>java.lang.util.regex.*</p>
<h4 id="常用的-Java-工具库"><a href="#常用的-Java-工具库" class="headerlink" title="常用的 Java 工具库"></a>常用的 Java 工具库</h4><p>commons.lang、commons. …、 guava-libraries、 netty</p>
<h4 id="API-amp-SPI"><a href="#API-amp-SPI" class="headerlink" title="API &amp; SPI"></a>API &amp; SPI</h4><p>API、API 和 SPI 的关系和区别<br>如何定义 SPI、SPI 的实现原理</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>异常类型、正确处理异常、自定义异常<br>Error 和 Exception<br>异常链、try-with-resources<br>finally 和 return 的执行顺序</p>
<p>常见的编译期异常：<br>1.ClassNotFoundException(类找不到异常)<br>2.FileNotFoundException（编译文件夹中找不到，就是发布到tomcat中的，不是工程中）<br>3.SQLException ：提供有关数据库访问错误或其他错误的信息的异常。（ 比如SQL语句写错，访问的表不存在，连接数据库失败等等）<br>4.IOexception：IO流异常。一般在读写数据的时候会出现这种问题。<br>5.EOFException:当输入过程中意外到达文件或流的末尾时，抛出此异常。</p>
<p>常见的运行时异常：<br>1.NullPointerException(空指针异常)<br>2.ArithmeticException（运算非法异常）<br>3.IndexOutOfBoundsException(数组越界异常)<br>4.ClassCastException(类转换异常)<br>5.ArrayStoreException(数据存储异常，操作数组时类型不一致)<br>6.BufferOverflowException(字节溢出异常—IO流操作)</p>
<p>ClassNotFoundException无法找到指定的类异常。<br>ClassNotfoundException时在编译时JVM加载不到类或者找不到类导致的.<br>当应用程序试图使用以下方法通过字符串名加载类时，抛出该异常：<br>1.Class类中的forName 方法。<br>2.ClassLoader类中的findSystemClass 方法。<br>3.ClassLoader类中的loadClass 方法。<br>但是没有找到具有指定名称的类的定义。<br>1 所需要的支持类库放错了地方，并没有放在类路径(CLASSPATH环境变量)里面。<br>2 使用了重复的类库，且版本不一致。导致低版本的被优先使用。<br>3 类名错了，一般是使用Class.forName的时候，手工指定了类名的情况。<br>4 没有导入纯JAVA驱动包。</p>
<p>NoClassDefFoundError<br>NoClassDefError是在运行时JVM加载不到类或者找不到类.<br>如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个错误往往是你使用new操作符来创建一个新的对象但却找不到该对象对应的类。这个时候就会导致NoClassDefFoundError.由于NoClassDefFoundError是由JVM引起的，所以不应该尝试捕捉这个错误。</p>
<h4 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h4><p>时区、冬令时和夏令时、时间戳、Java 中时间 API<br>格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系<br>SimpleDateFormat 的线程安全性问题<br>Java 8 中的时间处理<br>如何在东八区的计算机上获取美国时间</p>
<h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>Unicode、有了 Unicode 为啥还需要 UTF-8<br>GBK、GB2312、GB18030 之间的区别<br>UTF8、UTF16、UTF32 区别<br>URL 编解码、Big Endian 和 Little Endian<br>如何解决乱码问题</p>
<h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>Java 中语法糖原理、解语法糖<br>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式、::双冒号</p>
<h4 id="文件与流"><a href="#文件与流" class="headerlink" title="文件与流"></a>文件与流</h4><p>InputStream字节输入流<br>read()读取一个字节<br>read(byte[],off,len)读取数据到byte()数组中<br>close()关闭流，释放资源</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>transient：表示避免序列化<br>serializable：序列化的接口<br>什么是序列化与反序列化<br>序列化：对象—&gt;byte[]字节数组<br>反序列化：byte[]—&gt;对象<br>ObjectOutputStream<br>ObjectInputStream<br>致命缺点：java原生的序列化的两端必须是java语言，不能跨语言。第三方插件可以。</p>
<p>为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全</p>
</div><div class="tags"><a href="/tags/java%E5%9F%BA%E7%A1%80/"><i class="fa fa-tag"></i>java基础</a></div><div class="post-nav"><a class="pre" href="/2019/05/17/java%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/">计算机网络相关</a><a class="next" href="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/">并发与多线程相关</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'6Cf3b4KjUDTblsuWBz4jJcdU-gzGzoHsz',
  appKey:'l6wP9udo8YARTJrXperWuWgE',
  placeholder:'我想听你说一句… （留言请填写您的昵称和邮箱，方便回复以邮件形式通知您）',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://blog.frozenwind.online"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/emotion/">emotion</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">随笔</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">java基础</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">秒杀系统</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/java-web/" style="font-size: 15px;">java web</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/%E4%B8%80%E8%A8%80/" style="font-size: 15px;">一言</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/%E6%83%85%E4%B9%A6/" style="font-size: 15px;">情书</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">微信小程序</a> <a href="/tags/%E8%AF%8D/" style="font-size: 15px;">词</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">操作系统</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">java虚拟机</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98/" style="font-size: 15px;">系统问题</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/">微信小程序开发记录—爱河</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">mysql索引相关总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/14/mybatis%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">mybatis相关总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/14/mybatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">mybatis工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/08/java%E5%B9%B6%E5%8F%91%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">java并发—并发容器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/08/java8%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/">java8—接口中的静态方法和默认方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/java8%E2%80%94Stream-API/">java8—Stream API</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/java8%E2%80%94%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/">java8—方法引用与构造器引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/java8-%E5%9B%9B%E5%A4%A7%E5%86%85%E7%BD%AE%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/">java8—四大内置核心函数式接口详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/java8%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">java8—Lambda表达式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.scarboroughcoral.top/" title="scarboroughcoral" target="_blank">scarboroughcoral</a><ul></ul><a href="http://blog.wangxuyao.club/" title="冰冰冰淇淋君icecream" target="_blank">冰冰冰淇淋君icecream</a><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>