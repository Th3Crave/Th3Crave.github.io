<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>并发与多线程相关 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">并发与多线程相关</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/MoonAndStar/"><i class="fa fa-heart"> Moon&amp;Star</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">并发与多线程相关</h1><div class="post-meta">2019-05-17<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><a class="disqus-comment-count" href="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/#vcomment"><span class="valine-comment-count" data-xid="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/"></span><span> 条评论</span></a><div class="post-content"><p>原子性<br>可见性<br>有序性</p>
<h3 id="1并方包"><a href="#1并方包" class="headerlink" title="1并方包"></a>1并方包</h3><p>Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic、Semaphore、CountDownLatch、ConcurrentHashMap、Executors</p>
<h4 id="1-1JDK提供的并发容器总结"><a href="#1-1JDK提供的并发容器总结" class="headerlink" title="1.1JDK提供的并发容器总结"></a>1.1JDK提供的并发容器总结</h4><ul>
<li><strong>ConcurrentHashMap</strong>：线程安全的HashMap，乐观锁CAS。</li>
<li><strong>CopyOnWriteArrayList</strong>：线程安全的List，在读多写少的场合性能非常好，远好于Vector。</li>
<li><strong>ConcurrentLinkedQueue</strong>：高效的并发队列，使用链表实现。可以看做一个线程安全的LinkedList，这是一个非阻塞队列。</li>
<li><strong>BlockingQueue</strong>：这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，适合用于作为数据共享的通道。</li>
<li><strong>ConcurrentSkipListMap</strong>：跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。</li>
</ul>
<h4 id="1-2ConcurrentHashMap线程安全的底层实现"><a href="#1-2ConcurrentHashMap线程安全的底层实现" class="headerlink" title="1.2ConcurrentHashMap线程安全的底层实现"></a>1.2ConcurrentHashMap线程安全的底层实现</h4><p>JDK1.7 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，<br>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。<br>Segment实现了ReentrantLock，所以Segment是一种可重入锁，扮演锁的角色。HashEntry用于存储键值对数据，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment里的锁。</p>
<p>JDK1.8<br>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树(解决哈希冲突)。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）。<br>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<h3 id="2高可用高性能高并发"><a href="#2高可用高性能高并发" class="headerlink" title="2高可用高性能高并发"></a>2高可用高性能高并发</h3><h3 id="3并发与并行"><a href="#3并发与并行" class="headerlink" title="3并发与并行"></a>3并发与并行</h3><p>什么是并发、什么是并行<br>并发与并行的区别<br>操作系统层面：并行是两个或多个任务在同一时刻同时进行，需要多核CPU的支持；并发是两个或多个任务都请求运行，而处理器只能接受一个任务，就安排这几个任务轮流进行，宏观上是有多个任务在同时进行，实际上是因为CPU在不同的任务之间不停的切换，多个任务分时交替进行。并行是不抢占资源的，并发的多个任务之间是互相抢占资源的，只有多核CPU下才会并行执行。并发通常是提高运行在单处理器上的程序的性能。</p>
<h3 id="4什么是线程，与进程的区别"><a href="#4什么是线程，与进程的区别" class="headerlink" title="4什么是线程，与进程的区别"></a>4什么是线程，与进程的区别</h3><p>线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程<br>线程与进程的区别</p>
<p><strong>什么是线程</strong>：每个可以独立运行的程序都是一个进程，在一个进程中可以有多个执行单元同时运行，这些执行单元可以看作程序执行的一个个任务，被称为线程。操作系统中的每一个进程中至少存在一个线程，进程是资源分配的基本单元，线程是CPU调度的基本单位(在没有引入线程的时候，进程是资源分配和CPU调度的基本单位；引入进程是为了使多个程序能并发执行，提高资源利用率和系统吞吐量，引入线程是为了减少进程在并发执行时所付出的时空开销，线程切换比进程切换的开销要小，使操作系统具有更好的并发性。)<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.png"><br>线程就是独立的执行路径。在程序运行时，即使没有自己创建线程，后台也会存在多个线程，如gc线程、主线程；mian()称为主线程，为系统的入口点，用于执行整个程序。<br>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的。对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制。线程会带来额外的开销，如cpu调度时间、并发控制开销。Java内存模型中，每个线程在自己的工作内存交互，加载和存储主内存控制不当会造成数据不一致。</p>
<p><strong>线程的实现</strong>：<br>1)内核支持线程(Kernel Supported Threads)<br>2)用户级线程(User Level Threads)<br>3)组合方式</p>
<p><strong>创建多线程的方式</strong>：<br>少用继承，多用实现。<br>1)继承Thread类，重写Thread类的run()方法，调用继承自Thead类的start()方法开启线程。<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/thread.png"><br>2)实现Runnable接口，重写run()方法。通过new一个Thread(Runnable target)对象调用start()方法开启线程。<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/runnable.png"><br>3)实现Callable接口，重写call()方法。(j.u.c并发包下，用的不多)<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/callable.png"></p>
<p><strong>守护线程和用户线程</strong>：默认情况下，我们所创建的线程都是用户线程；被标记为守护线程的线程，程序不会等它执行完才停止，当所有的用户线程都执行完了程序就停止了，守护线程为用户线程服务。</p>
<p><strong>线程的状态</strong>：<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png"><br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%812.png"><br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpg"><br>新生状态：创建一个线程对象后，该线程对象就处于新建状态，此时它不能运行，和其他java对象一样，仅仅由java虚拟机为其分配了内存，没有表现出任何线程的动态特征。<br>就绪状态：当线程对象调用了start()方法后，该线程就进入就绪状态(也称可运行状态)。处于就绪状态的线程位于可运行池中，此时它只是具备了运行的条件，能否获得CPU的使用权开始运行，还需要等待系统的调度。<br>运行状态：如果处于就绪状态的线程获得了CPU的使用权，开始执行run()方法中的线程执行体，则该线程处于运行状态。当一个线程启动后，它不可能一直处于运行状态(除非它的线程执行体足够短，瞬间就结束了)，当使用完系统分配的时间后，系统就会剥夺该线程占用的CPU资源，让其他线程获得执行的机会。只有处于就绪状态的线程才会转换到运行状态。<br>死亡状态：线程的run()方法正常执行完毕或者线程抛出一个未捕获的异常Exception、错误Error，线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能再转换到其他状态。<br>阻塞状态：一个正在执行的线程在某些情况下，会放弃CPU的使用权，进入阻塞状态。线程进入阻塞状态后，就不能进入排队队列。只有当引起阻塞的原因被消除后，线程才可以转为就绪状态。</p>
<p><strong>线程停止</strong>：<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2.png"></p>
<p><strong>线程休眠</strong>：<br>sleep()是静态/类方法，只能控制当前正在运行的线程休眠/阻塞，而不能控制其他线程休眠。当休眠时间结束后，线程就会返回到就绪状态，而不是立即开始运行。<br>sleep(long millis)指定当前正在执行的线程阻塞的毫秒数。<br>sleep()方法会抛出InterruptedException异常。<br>sleep时间达到后线程从阻塞状态进入就绪状态。<br>sleep可以模拟网络延时、倒计时等。<br>每一个对象都有一个锁，sleep不能释放锁。</p>
<p><strong>线程让步</strong>：<br>yield()方法让当前正在执行的线程暂停，不会阻塞该线程，而是将线程从运行状态转换成就绪状态，让CPU调度器重新调度一次。当某个线程调用yield()方法后，只有与当前线程优先级相同或者更高的线程才能获得执行的机会。</p>
<p><strong>线程插队</strong>：<br>join()方法，当在某个线程中调用其他线程的join()方法时，调用的线程将被阻塞，直到被join()方法加入的线程执行完成后她才会继续执行。</p>
<p><strong>线程的优先级</strong>：java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。线程调度器按照线程的优先级决定应调度哪个线程来执行。线程的优先级用数字表示范围从1到10。优先级的设定建议在start()调用前。程序在运行期间，处于就绪状态的每个线程都有自己的优先级，默认main线程具有普通优先级5。优先级越高的线程获得cpu执行的机会越大，不代表绝对的先后顺序。</p>
<h3 id="5线程池"><a href="#5线程池" class="headerlink" title="5线程池"></a>5线程池</h3><p>自己设计线程池、submit() 和 execute()、线程池原理<br>为什么不允许使用 Executors 创建线程池</p>
<h3 id="6线程安全"><a href="#6线程安全" class="headerlink" title="6线程安全"></a>6线程安全</h3><p>改(增加、删除、修改)数据时会有线程不安全现象，三大经典案例：售票、银行账户、对容器操作。这时需要进行并发控制，保证线程安全。</p>
<h4 id="6-1死锁"><a href="#6-1死锁" class="headerlink" title="6.1死锁"></a>6.1死锁</h4><h4 id="6-2死锁如何排查"><a href="#6-2死锁如何排查" class="headerlink" title="6.2死锁如何排查"></a>6.2死锁如何排查</h4><h4 id="6-3线程安全和内存模型的关系"><a href="#6-3线程安全和内存模型的关系" class="headerlink" title="6.3线程安全和内存模型的关系"></a>6.3线程安全和内存模型的关系</h4><h3 id="7锁"><a href="#7锁" class="headerlink" title="7锁"></a>7锁</h3><p>CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁</p>
<p><strong>悲观锁</strong>，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。悲观锁适用于多写的场景。</p>
<p><strong>乐观锁</strong>就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。CAS 是乐观锁的一种实现方式。乐观锁适用于读比较多写比较少的场景。</p>
<p><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png"><br><strong>可重入锁</strong>：锁可以连续使用，并且锁里面有一个计数器</p>
<ol>
<li>一个同步方法可以调用另一个同步方法，一个线程已经拥有某个对象的锁，再次申请时仍然会获得该对象的锁，synchronized的锁是可以重入的。</li>
<li>锁重入还有一种情况就是，子类调用父类的同步方法。</li>
</ol>
<p><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/CAS.png"><br>CAS算法，compare and swap（比较与交换）。<br>ABA问题：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p>
<p><strong>公平锁</strong>，当一个线程运行结束之后，其他线程获得锁是公平的，先等待先得到。<br><strong>非公平锁</strong>，当一个线程运行结束之后，其他线程获得锁是随机的，非公平锁也叫竞争锁。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><h4 id="synchronize和lock"><a href="#synchronize和lock" class="headerlink" title="synchronize和lock"></a>synchronize和lock</h4><h3 id="8死锁"><a href="#8死锁" class="headerlink" title="8死锁"></a>8死锁</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>两个或多个线程各自抱着自己占有的资源，都不释放，都在等待对方的资源。<br>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。</p>
<h4 id="死锁如何解决"><a href="#死锁如何解决" class="headerlink" title="死锁如何解决"></a>死锁如何解决</h4><p>不要锁套锁，不要在同一个代码块中持有多个对象的锁。</p>
<h3 id="9-synchronized"><a href="#9-synchronized" class="headerlink" title="9 synchronized"></a>9 synchronized</h3><p>线程安全问题，其实就是由多个线程同时处理共享资源所导致的。解决线程安全问题要保证处理共享资源的代码在任何时刻只能有一个线程访问。Java中提供的同步机制，当多个线程使用同一个共享资源时，可以将处理共享资源的代码放置在一个代码块中，使用synchronized关键字来修饰，被称为同步代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	操作共享资源代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，lock是一个锁对象，它是同步代码块的关键。当线程执行同步代码块时，首先会检查锁对象的标志位，默认情况下标志位为1，此时线程会执行同步代码块，同时将锁对象的标志位置为0。当一个新的线程执行到这段同步代码块时，由于锁对象的标志位为0，新线程会发生阻塞，等待当前线程执行完同步代码块后，锁对象的标志位被置为1，新线程才能进入同步代码块执行其中的代码。<br>使用synchronized关键字来修饰方法，被修饰的方法称为同步方法，在某一时刻只允许一个线程来访问，访问该方法的其他线程都会阻塞，直到当前线程访问完毕后，其他线程才有机会执行方法。</p>
<p><strong>同步代码块</strong>中的锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是唯一的，用共享资源作为锁对象(同步监视器)。“任意”说的是共享锁对象的类型。锁对象的创建代码不能放到run()方法中，否则每个线程运行到run()方法都会创建一个锁对象，这样每个线程都会有一个不同的锁，每个锁都有自己的标志位。<br><strong>同步成员方法</strong>也有自己的锁，它的锁就是当前调用该方法的对象，也就是this指向的对象。这样做的好处是，同步方法被所有线程所共享，方法所在的对象相对于所有线程来说是唯一的，从而保证了锁的唯一性。当一个线程执行该方法时，其他线程就不能进入该方法中，直到这个线程执行完这个方法为止，从而达到线程同步。<br><strong>Java中静态方法</strong>的锁是该方法所在的类的class对象，该对象可以用“类名.class”的方式获取。<br>同步解决了多个线程同时访问共享数据时的线程安全问题，只要加上一个锁，在同一时间内只能有一个线程执行，其它所有需要该锁的线程都被挂起。但是线程在执行同步代码时每次都要判断锁的状态，多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<h4 id="1-synchronized是如何实现的？"><a href="#1-synchronized是如何实现的？" class="headerlink" title="1.synchronized是如何实现的？"></a>1.synchronized是如何实现的？</h4><h4 id="2-Synchronized和Lock之间关系"><a href="#2-Synchronized和Lock之间关系" class="headerlink" title="2.Synchronized和Lock之间关系"></a>2.Synchronized和Lock之间关系</h4><p>JVM - Synchronized<br>J.U.C - Lock<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E5%90%8C%E6%AD%A5%E7%9B%91%E8%A7%86%E5%99%A8-%E9%94%81.png"></p>
<h4 id="3-不使用-synchronized-如何实现一个线程安全的单例"><a href="#3-不使用-synchronized-如何实现一个线程安全的单例" class="headerlink" title="3.不使用 synchronized 如何实现一个线程安全的单例"></a>3.不使用 synchronized 如何实现一个线程安全的单例</h4><h4 id="4-synchronized-和原子性、可见性和有序性之间的关系"><a href="#4-synchronized-和原子性、可见性和有序性之间的关系" class="headerlink" title="4.synchronized 和原子性、可见性和有序性之间的关系"></a>4.synchronized 和原子性、可见性和有序性之间的关系</h4><h3 id="10-volatile"><a href="#10-volatile" class="headerlink" title="10 volatile"></a>10 volatile</h3><h4 id="1-happens-before、内存屏障、编译器指令重排和CPU指令重排序"><a href="#1-happens-before、内存屏障、编译器指令重排和CPU指令重排序" class="headerlink" title="1.happens-before、内存屏障、编译器指令重排和CPU指令重排序"></a>1.happens-before、内存屏障、编译器指令重排和CPU指令重排序</h4><p>happen-before：发生之前<br>我们写的代码很可能根本没有按照我们期望的顺序执行，因为编译器和CPU会尝试重排指令使得代码更快地运行。<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/happenbefore.png"><br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96.png"></p>
<h4 id="2-volatile-的实现原理"><a href="#2-volatile-的实现原理" class="headerlink" title="2.volatile 的实现原理"></a>2.volatile 的实现原理</h4><p><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/volatile.png"></p>
<h4 id="3-volatile-和原子性、可见性和有序性之间的关系"><a href="#3-volatile-和原子性、可见性和有序性之间的关系" class="headerlink" title="3.volatile 和原子性、可见性和有序性之间的关系"></a>3.volatile 和原子性、可见性和有序性之间的关系</h4><p>volatile保证线程间变量的可见性。当线程A对变量X进行了修改后，在线程A后面执行的其他线程能看到变量X的改动。volatile的可见性只保证数据的同步，开销比synchronized小。<br>volatile不能保证原子性。<br>volatile避免指令重排。</p>
<h4 id="4-有了synchronized为什么还需要volatile"><a href="#4-有了synchronized为什么还需要volatile" class="headerlink" title="4.有了synchronized为什么还需要volatile"></a>4.有了synchronized为什么还需要volatile</h4><p>synchronized实现了数据在同一时刻只能有一个线程对数据访问，volatile实现的是同时可以多个线程在访问数据，但是只要数据发生了变化，便确保其他线程及时“感知”这种变化。<br>volatile关键字，使一个变量在多个线程之间可见。A、B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道。使用volatile关键字，会让所有线程都会读取到变量的修改值。<br>使用volatile后，当堆内存中的变量发生改变之后会强制所有线程都去堆内存中读取该变量的值。<br>volatile并不能保证多个线程共同修改变量时所带来的不一致问题，也就是说volatile不能替代synchronized。</p>
<p>在Object()类中提供了wait()、notify()、notifyAll()方法用于解决线程间的通信问题。任何类的实例对象都可以直接使用这些方法。</p>
<h3 id="11-sleep-和-wait"><a href="#11-sleep-和-wait" class="headerlink" title="11 sleep 和 wait"></a>11 sleep 和 wait</h3><h3 id="12-wait-和-notify"><a href="#12-wait-和-notify" class="headerlink" title="12 wait 和 notify"></a>12 wait 和 notify</h3><h3 id="13-notify-和-notifyAll"><a href="#13-notify-和-notifyAll" class="headerlink" title="13 notify 和 notifyAll"></a>13 notify 和 notifyAll</h3><p>wait()使当前线程放弃同步锁并进入等待，直到其他线程进入此同步锁，并调用notify()方法，或notifyAll()方法唤醒该线程为止。<br>notify()唤醒此同步锁上等待的第一个调用wait()方法的线程。<br>notifyAll()唤醒此同步锁上调用wait()方法的所有线程。<br>这三个方法的调用者都应该是同步锁对象，只能在同步方法或者同步代码块中使用，如果这三个方法的调用者不是同步锁对象，java虚拟机会抛出IllegalMonitorStateException异常。</p>
<h3 id="14-ThreadLocal"><a href="#14-ThreadLocal" class="headerlink" title="14 ThreadLocal"></a>14 ThreadLocal</h3><p><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/threadlocal.png"><br>ThreadLocal用一种存储变量与线程绑定的方式，在每个线程中用自己的ThreadLocalMap安全隔离变量，解决多线程中相同变量的访问冲突问题，为解决多线程程序的并发问题提供了一种新的思路，如为每个线程创建一个独立的数据库连接。因为是线程绑定的，所以在很多场景也被用来实现线程参数传递，如Spring的RequestContextHolder。也因为每个线程拥有自己唯一的ThreadLocalMap，所以ThreadLocal是天然线程安全的。<br>threadlocal提供当前线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p>
<p>ThreadLocal的官方API解释为：<br>“该类提供了线程局部(thread-local)变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其get或set方法的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal实例通常是类中的private-static字段它们希望将状态与某一个线程（例如，用户ID或事务ID）相关联。”<br>大概的意思有两点：<br>1.ThreadLocal提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是一致的，这就是所谓的线程隔离。<br>2.如果要使用ThreadLocal，通常定义为private-static类型，在我看来最好是定义为private static final类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread(); // 获取当前线程</span><br><span class="line">    ThreadLocalMap map = getMap(t); // 拿到当前线程的 ThreadLocalMap</span><br><span class="line">    if (map != null) // 判断 ThreadLocalMap 是否存在</span><br><span class="line">        map.set(this, value); // 调用 ThreadLocalMap 的 set 方法</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value); // 创建 ThreadLocalMap</span><br><span class="line">&#125;</span><br><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this); //调用  ThreadLocalMap 的 getEntry 方法</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue(); // 如果还没有设置，可以用子类实现 initialValue ，自定义初始值。</span><br><span class="line">&#125;</span><br><span class="line">public void remove() &#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    if (m != null)</span><br><span class="line">        m.remove(this); // 调用 ThreadLocalMap 的 remove方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从代码实现中可以看出，每个线程Thread都会维护自己的ThreadLocalMap，这个map的key则是ThreadLocal类本身，而value则是我们保存的数据。ThreadLocal在多线程中是被公共持有的，被隔离的数据实际是存放在每个线程的ThreadLocalMap中的，只不过是通过ThreadLocal的引用得到每个线程维护的ThreadLocalMap中的value。</p>
<h4 id="14-1ThreadLocalMap"><a href="#14-1ThreadLocalMap" class="headerlink" title="14.1ThreadLocalMap"></a>14.1ThreadLocalMap</h4><p>ThreadLocalMap是ThreadLocal内部的一个Map实现，然而它并没有实现任何集合的接口规范，因为它仅供内部使用，数据结构采用数组+开放地址法，Entry 继承WeakReference，是基于ThreadLocal这种特殊场景实现的Map，它的实现方式很值得研究。<br>ThreadLocalMap的Entry定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-2ThreadLocal在Spring事务管理中的应用"><a href="#14-2ThreadLocal在Spring事务管理中的应用" class="headerlink" title="14.2ThreadLocal在Spring事务管理中的应用"></a>14.2ThreadLocal在Spring事务管理中的应用</h4><p>在事务管理中，在service类中的涉及到事务的方法，每个事务的上下文都应该是独立拥有数据库的connection连接的，否则在数据提交回滚过程中就会产生冲突。<br>spring中使用ThreadLocal来设计TransactionSynchronizationManager类，实现了事务管理与数据访问服务的解耦，同时也保证了多线程环境下connection的线程安全问题。</p>
<h3 id="15写一个死锁的程序"><a href="#15写一个死锁的程序" class="headerlink" title="15写一个死锁的程序"></a>15写一个死锁的程序</h3><p>死锁：两个线程都需要对方所占用的锁，也都无法释放自己所拥有的锁，于是这两个线程都处于了阻塞状态，互相等待。</p>
<h3 id="16写代码来解决生产者消费者问题"><a href="#16写代码来解决生产者消费者问题" class="headerlink" title="16写代码来解决生产者消费者问题"></a>16写代码来解决生产者消费者问题</h3><p><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png"></p>
<h4 id="线程协作：生产者消费者模式"><a href="#线程协作：生产者消费者模式" class="headerlink" title="线程协作：生产者消费者模式"></a>线程协作：生产者消费者模式</h4><p>区别设计模式，设计模式是处理java设计的类与类之间的关系。<br>生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。<br>对于生产者，没有生产产品之前，要通知消费者等待；生产了产品之后，又需要马上通知消费者消费。<br>对于消费者，在消费之前，要通知生产者已经消费完，需要继续生产新产品以供消费。<br>在生产者消费者问题中，仅有synchronized是不够的。synchronized可阻止并发更新同一个共享资源，实现了同步；但不能用来实现不同线程之间的消息传递(通信)。<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E8%A7%A3%E5%86%B31.png"><br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E8%A7%A3%E5%86%B32.png"></p>
<h3 id="17lambda表达式"><a href="#17lambda表达式" class="headerlink" title="17lambda表达式"></a>17lambda表达式</h3><p>避免匿名内部类定义过多，其实质属于函数式编程的概念。<br>lambda表达式简化简单线程(用一次)的使用</p>
<h3 id="18定时调度"><a href="#18定时调度" class="headerlink" title="18定时调度"></a>18定时调度</h3><p>某一个有规律的时间点干某件事</p>
<h4 id="18-1通过Timer和Timetask实现定时启动某个线程。"><a href="#18-1通过Timer和Timetask实现定时启动某个线程。" class="headerlink" title="18.1通过Timer和Timetask实现定时启动某个线程。"></a>18.1通过Timer和Timetask实现定时启动某个线程。</h4><p>java.util.Timer：类似闹钟的功能，本身实现的就是一个线程。<br>java.util.TimerTask：一个抽象类，该类实现了Runnable接口，所以该类具有多线程的能力。</p>
<h4 id="18-2quartz任务调度框架"><a href="#18-2quartz任务调度框架" class="headerlink" title="18.2quartz任务调度框架"></a>18.2quartz任务调度框架</h4><p>组成部分：Scheduler调度器，控制所有的调度；Trigger触发条件，采用DSL模式；JobDetail需要处理的具体的任务；Job执行逻辑。<br>DSL模式：领域特定语言(Domain-specific)，针对一个特定的领域，具有受限表达性的一种计算机程序语言。</p>
<h3 id="19Lock"><a href="#19Lock" class="headerlink" title="19Lock"></a>19Lock</h3><p>J.U.C下Lock接口</p>
<h4 id="19-1什么是重入锁"><a href="#19-1什么是重入锁" class="headerlink" title="19.1什么是重入锁"></a>19.1什么是重入锁</h4><h4 id="19-2设计一个重入锁需要考虑哪些问题？"><a href="#19-2设计一个重入锁需要考虑哪些问题？" class="headerlink" title="19.2设计一个重入锁需要考虑哪些问题？"></a>19.2设计一个重入锁需要考虑哪些问题？</h4><p>满足重入特性；满足互斥特性。</p>
<ol>
<li>一种共享机制来实现互斥，共享变量来实现互斥<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//0/1</span></span><br><span class="line">compareAndSetState</span><br></pre></td></tr></table></figure></li>
<li>剩下的没有获得锁的线程怎么办？ 排队</li>
<li>处于排队的线程应该是什么状态？ 让线程变成阻塞状态</li>
<li>通过一种方式去记住是哪个线程获得锁<br><img src="/2019/05/17/java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/chongrusuo.png"></li>
</ol>
</div><div class="tags"><a href="/tags/java%E5%9F%BA%E7%A1%80/"><i class="fa fa-tag"></i>java基础</a></div><div class="post-nav"><a class="pre" href="/2019/05/17/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">java基础知识</a><a class="next" href="/2019/05/15/%E5%9F%BA%E4%BA%8ESpringBoot%E7%9A%84%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E5%B9%B3%E5%8F%B0/">项目2.0 基于SpringBoot的校园商铺平台</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'NPvQJfh7XNHqMqbmVYOg5VE5-9Nh9j0Va',
  appKey:'hgOdKtBYlsJzigDKoXqevrSI',
  placeholder:'我想听你说一句… （留言请填写您的昵称和邮箱，方便回复以邮件形式通知您）',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://blog.frozenwind.online"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/emotion/">emotion</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">随笔</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">java基础</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">秒杀系统</a> <a href="/tags/java-web/" style="font-size: 15px;">java web</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/%E4%B8%80%E8%A8%80/" style="font-size: 15px;">一言</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">微信小程序</a> <a href="/tags/%E8%AF%8D/" style="font-size: 15px;">词</a> <a href="/tags/%E6%83%85%E4%B9%A6/" style="font-size: 15px;">情书</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">操作系统</a> <a href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">java虚拟机</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98/" style="font-size: 15px;">系统问题</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/11/21/%E4%BB%8A%E5%A4%A9%E8%B5%B7%E7%9A%84%E6%AF%8F%E6%99%9A-%E4%BD%A0%E8%A6%81%E7%8F%8D%E6%83%9C%E5%B2%81%E6%9C%88/">今天起的每晚 你要珍惜岁月</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/">微信小程序开发记录—爱河</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">mysql索引相关总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/14/mybatis%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">mybatis相关总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/14/mybatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">mybatis工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/08/java%E5%B9%B6%E5%8F%91%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">java并发—并发容器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/08/java8%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/">java8—接口中的静态方法和默认方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/java8%E2%80%94Stream-API/">java8—Stream API</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/java8%E2%80%94%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/">java8—方法引用与构造器引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/java8-%E5%9B%9B%E5%A4%A7%E5%86%85%E7%BD%AE%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/">java8—四大内置核心函数式接口详解</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.scarboroughcoral.top/" title="scarboroughcoral" target="_blank">scarboroughcoral</a><ul></ul><a href="http://blog.wangxuyao.club/" title="冰冰冰淇淋君icecream" target="_blank">冰冰冰淇淋君icecream</a><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>