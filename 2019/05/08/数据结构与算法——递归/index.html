<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>数据结构与算法——递归 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构与算法——递归</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕成锋的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 由来</i></a><a href="/MoonAndStar/"><i class="fa fa-heart"> MoonAndStar</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构与算法——递归</h1><div class="post-meta">May 8, 2019<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><a class="disqus-comment-count" href="/2019/05/08/数据结构与算法——递归/#vcomment"><span class="valine-comment-count" data-xid="/2019/05/08/数据结构与算法——递归/"></span><span> 条评论</span></a><div class="post-content"><p>推荐注册返佣金——现在很多App都有这个功能。用户A推荐用户B来注册，用户B又推荐了用户C来注册。可以说，用户C的“最终推荐人”为用户A，用户B的“最终推荐人”也为用户A，用户A没有“最终推荐人”。<br>一般来说，会通过数据库来记录这种推荐关系。在数据库表中，可以记录两行数据，其中actor_id表示用户id，referrer_id表示推荐人id。<br><img src="/2019/05/08/数据结构与算法——递归/acre.jpg" alt=""><br>基于这个背景，给定一个用户ID，如何查找这个用户的“最终推荐人”？</p>
<h3 id="1-关于递归"><a href="#1-关于递归" class="headerlink" title="1.关于递归"></a>1.关于递归</h3><p>数据结构与算法，有两个最难理解的知识点，一个是动态规划，一个是递归。<br>递归是一中应用非常广泛的算法(或者编程技巧)，有很多数据结构与算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等。<br>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</p>
<h3 id="2-递归需要满足的三个条件"><a href="#2-递归需要满足的三个条件" class="headerlink" title="2.递归需要满足的三个条件"></a>2.递归需要满足的三个条件</h3><h4 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1)一个问题的解可以分解为几个子问题的解"></a>1)一个问题的解可以分解为几个子问题的解</h4><p>子问题就是数据规模更小的问题。</p>
<h4 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h4><h4 id="3-存在递归终止条件"><a href="#3-存在递归终止条件" class="headerlink" title="3)存在递归终止条件"></a>3)存在递归终止条件</h4><p>把问题分解为子问题，子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，需要有终止条件。</p>
<h3 id="3-如何编写递归代码"><a href="#3-如何编写递归代码" class="headerlink" title="3.如何编写递归代码"></a>3.如何编写递归代码</h3><p>写递归代码最关键的是写出递推公式，找到终止条件，将递推公式转化为代码。<br>假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问这n个台阶有多少中走法？<br>如果有7个台阶，可以2，2，2，1这样上去，也可以1，2，1，1，2这样，走法很多，如何用编程求得总共有多少中走法？<br>想一下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法加上先走2阶后，n-2个台阶的走法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure></p>
<p>再来看终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法，所以f(1)=1。然而，只有这一个是不够的。<br>n=2时，f(2)=f(1)+f(0)，如果递归终止条件只有一个f(1)=1，那f(2)就无法求解了，而f(0)是客观不可行的，所以要把f(2)=2作为一个终止条件，表示走两个台阶，有两种走法，一步走完或者分两步来走。<br>把递归终止条件和递推公式放到一起就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(1)=1</span><br><span class="line">f(2)=2</span><br><span class="line">f(n)=f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure></p>
<p>转化为递归代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n == 1) return 1;</span><br><span class="line">	if(n == 2) return 2;</span><br><span class="line">	return f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"><a href="#写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。" class="headerlink" title="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"></a>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。</h4><p>当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解。像刚刚这个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归坪铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。<br>对于递归代码，这种试图想搞清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。<br>如果一个问题A可以分解为若干子问题B、C、D，可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，只需要思考问题A和子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题和子子问题，子子问题和子子子问题之间的关系，屏蔽掉递归细节。</p>
<h4 id="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"><a href="#编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。" class="headerlink" title="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"></a>编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。</h4><h3 id="4-递归代码要警惕堆栈溢出"><a href="#4-递归代码要警惕堆栈溢出" class="headerlink" title="4.递归代码要警惕堆栈溢出"></a>4.递归代码要警惕堆栈溢出</h3><p>为什么递归代码容易造成堆栈溢出？如何预防堆栈溢出？<br>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>上面的例子，如果将系统栈或者JVM堆栈大小设置为1KB，在求解f(1999)时便会出现如下堆栈报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br></pre></td></tr></table></figure></p>
<p>如何避免出现堆栈溢出？<br>声明一个全局变量，可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度(比如1000)之后，就不继续往下再递归了，直接返回报错。<br>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，会影响代码的可读性。所以，如果最大深度比较小，比如10、50，可以用这种方法，否则这种方法并不是很实用。</p>
<h3 id="5-递归代码要警惕重复计算"><a href="#5-递归代码要警惕重复计算" class="headerlink" title="5.递归代码要警惕重复计算"></a>5.递归代码要警惕重复计算</h3><p><img src="/2019/05/08/数据结构与算法——递归/fchongfujisuan.jpg" alt=""><br>从图中，可以看到，想要计算f(5),需要先计算f(4)和 f(3)，而计算f(4) 还需要计算f(3)，因此f(3) 就被计算了很多次，这就是重复计算问题。<br>为了避免重复计算，可以通过一个数据结构(比如散列表)来保存已经求解过的f(k)。当递归调用到f(k)时，先从中看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">  if (n == 1) return 1;</span><br><span class="line">  if (n == 2) return 2;</span><br><span class="line">  </span><br><span class="line">  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span><br><span class="line">  if (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    return hasSovledList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int ret = f(n-1) + f(n-2);</span><br><span class="line">  hasSovledList.put(n, ret);</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。</p>
<h3 id="6-递归代码改写为非递归代码"><a href="#6-递归代码改写为非递归代码" class="headerlink" title="6.递归代码改写为非递归代码"></a>6.递归代码改写为非递归代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int f(n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n == 1) return 1;</span><br><span class="line">	if(n == 2) return 2;</span><br><span class="line"></span><br><span class="line">	int ret = 0;</span><br><span class="line">	int pre = 2;</span><br><span class="line">	int prepre = 1;</span><br><span class="line">	for(int i = 3; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = pre + prepre;</span><br><span class="line">		prepre = pre;</span><br><span class="line">		pre = ret;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line">//刚好这个走台阶的问题类似斐波那契数列</span><br></pre></td></tr></table></figure>
<p>抽象出递推公式、初始值和边界条件，用迭代循环实现改写。<br>是不是所有的递归代码都可以改写为这种迭代循环的非递归写法？<br>笼统地讲，是的。因为递归本身就是借助栈来实现的，因不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>
<h3 id="如何找到“最终推荐人”"><a href="#如何找到“最终推荐人”" class="headerlink" title="如何找到“最终推荐人”"></a>如何找到“最终推荐人”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long findRootReferrerId(long actorId)</span><br><span class="line">&#123;</span><br><span class="line">	Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">	if(referrerId == null) return actorId;</span><br><span class="line">	return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际项目中，这三行代码并不能工作，为啥？这里面有两个问题。<br>一，如果递归很深，可能会有堆栈溢出的问题。<br>二，如果数据库里存在脏数据，还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C 的推荐人是A，这样就会发生死循环。<br>第一个问题，可以用限制递归深度来解决。<br>第二个问题，自动检测A-B-C-A这种“环”的存在。如何来检测环的存在？</p>
<h3 id="思考：对于递归代码，有什么好的调试方法？"><a href="#思考：对于递归代码，有什么好的调试方法？" class="headerlink" title="思考：对于递归代码，有什么好的调试方法？"></a>思考：对于递归代码，有什么好的调试方法？</h3><p>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。</p>
</div><div class="tags"><a href="/tags/数据结构与算法/">数据结构与算法</a></div><div class="post-nav"><a class="pre" href="/2019/05/12/基于SSM的校园商铺平台/">项目1.0 基于SSM的校园商铺平台</a><a class="next" href="/2019/05/08/解决org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found-问题/">解决org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)问题</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'6Cf3b4KjUDTblsuWBz4jJcdU-gzGzoHsz',
  appKey:'l6wP9udo8YARTJrXperWuWgE',
  placeholder:'我想听你说一句… （留言请填写您的昵称和邮箱，方便回复以邮件形式通知您）',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://blog.frozenwind.online"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/emotion/">emotion</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/阿里云服务器/" style="font-size: 15px;">阿里云服务器</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/java基础/" style="font-size: 15px;">java基础</a> <a href="/tags/java-web/" style="font-size: 15px;">java web</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/情书/" style="font-size: 15px;">情书</a> <a href="/tags/词/" style="font-size: 15px;">词</a> <a href="/tags/java虚拟机/" style="font-size: 15px;">java虚拟机</a> <a href="/tags/系统问题/" style="font-size: 15px;">系统问题</a> <a href="/tags/一言/" style="font-size: 15px;">一言</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/数据结构与算法——排序/">数据结构与算法——排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/java与模式——模式与设计原则/">java与模式——模式与设计原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/13/基于SpringBoot的校园商铺平台/">项目2.0 基于SpringBoot的校园商铺平台</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/12/基于SSM的校园商铺平台/">项目1.0 基于SSM的校园商铺平台</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/08/数据结构与算法——递归/">数据结构与算法——递归</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/08/解决org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found-问题/">解决org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/06/MySQL技术内幕——MySQL体系结构和存储引擎1/">MySQL技术内幕——MySQL体系结构和存储引擎1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/06/数据结构与算法——队列/">数据结构与算法——队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/05/数据结构与算法——栈/">数据结构与算法——栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/29/和小北说的999句话/">和小北说的999句话</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.scarboroughcoral.top/" title="scarboroughcoral" target="_blank">scarboroughcoral</a><ul></ul><a target="_blank"></a><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" color="100,99,98" opacity="0.7" zindex="-1" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.3/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>