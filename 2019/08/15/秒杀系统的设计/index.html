<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>秒杀系统的设计 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">秒杀系统的设计</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/MoonAndStar/"><i class="fa fa-heart"> Moon&amp;Star</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">秒杀系统的设计</h1><div class="post-meta">2019-08-15<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><a class="disqus-comment-count" href="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/#vcomment"><span class="valine-comment-count" data-xid="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/"></span><span> 条评论</span></a><div class="post-content"><h3 id="秒杀系统常见问题"><a href="#秒杀系统常见问题" class="headerlink" title="秒杀系统常见问题"></a>秒杀系统常见问题</h3><ol>
<li>简单说一下秒杀系统的设计思路?</li>
<li>你怎么实现秒杀业务的？</li>
<li>你怎么保证秒杀成功的？</li>
<li>秒杀操作的策略是什么？</li>
<li>你使用的Redis有什么用？</li>
<li>你为什么使用Redis中间件？</li>
<li>你测试过你这个系统的抗压能力么？</li>
<li>你使用过什么方法来测试你的系统并发量？</li>
<li>你觉得你这个系统还可以再优化么？</li>
<li>你觉得你这个系统的瓶颈在哪里？还可以在哪些方向做进一步优化?</li>
<li>最后一件商品，多个用户同时抢购怎么处理？（超卖问题）</li>
</ol>
<h3 id="秒杀系统特点"><a href="#秒杀系统特点" class="headerlink" title="秒杀系统特点"></a>秒杀系统特点</h3><ol>
<li>秒杀业务简单，买家查询，买家下订单，减库存。</li>
<li>秒杀时网站访问流量激增，出现峰值；</li>
<li>访问请求数量远大于实际需求量。</li>
</ol>
<h3 id="整体设计思路"><a href="#整体设计思路" class="headerlink" title="整体设计思路"></a>整体设计思路</h3><ul>
<li>限流：屏蔽掉无用的流量，允许少部分流量流向后端。</li>
<li>削峰：瞬时大流量峰值容易压垮系统，解决这个问题是重中之重。常用的消峰方法有异步处理、缓存和消息中间件等技术。</li>
<li>异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。</li>
<li>内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。</li>
<li>可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。</li>
<li>消息队列：消息队列可以削峰，将拦截大量并发请求，这也是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。</li>
<li>充分利用缓存：利用缓存可极大提高系统读写速度。<br><img src="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/fangan.png"></li>
</ul>
<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h3 id="1-集成redis"><a href="#1-集成redis" class="headerlink" title="1.集成redis"></a>1.集成redis</h3><p>通用缓存key封装<br>接口：定义一些规范<br>抽象类：定义一些通用的实现<br>实现类：特定类的具体实现。</p>
<h3 id="2-两次MD5"><a href="#2-两次MD5" class="headerlink" title="2.两次MD5"></a>2.两次MD5</h3><p>1）用户端：PASS=MD5(明文+固定salt)，第一次MD5防止用户的密码明文在网络上传输。<br>2）服务端：PASS=MD5(用户输入+随机salt)，服务端的MD5是防止数据库中的密码被反查，双重保险。</p>
<h3 id="3-数据表的主键"><a href="#3-数据表的主键" class="headerlink" title="3.数据表的主键"></a>3.数据表的主键</h3><p>Twitter的分布式雪花算法SnowFlake每秒自增生成26个万个可排序的ID </p>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h3 id="JSR303参数检验"><a href="#JSR303参数检验" class="headerlink" title="JSR303参数检验"></a>JSR303参数检验</h3><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><h4 id="session和cookie的区别和联系"><a href="#session和cookie的区别和联系" class="headerlink" title="session和cookie的区别和联系"></a>session和cookie的区别和联系</h4><p>1.session保存在服务器，客户端不知道其中的信息；cookie保存在客户端，服务器能够知道其中的信息。<br>2.session中保存的是对象，cookie中保存的是字符串。<br>3.session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的。<br>4.session需要借助cookie才能正常工作，如果客户端完全禁止cookie，session将失效。<br>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于在服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上还有其他选择。<br>Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p>
<p>如何利用实现自动登录：当用户在某个网站注册后，就会收到一个惟一用户ID的cookie。客户后来重新连接时，这个用户ID会自动返回，服务器对它进行检查，确定它是否为注册用户且选择了自动登录，从而使用户无需给出明确的用户名和密码，就可以访问服务器上的资源。<br>如何根据用户的爱好定制站点：网站可以使用cookie记录用户的意愿。对于简单的设置，网站可以直接将页面的设置存储在cookie中完成定制。然而对于更复杂的定制，网站只需仅将一个惟一的标识符发送给用户，由服务器端的数据库存储每个标识符对应的页面设置。</p>
<h4 id="分布式Session的集中实现方式"><a href="#分布式Session的集中实现方式" class="headerlink" title="分布式Session的集中实现方式"></a>分布式Session的集中实现方式</h4><p>1.基于数据库的Session共享<br>2.基于NFS共享文件系统<br>3.基于memcached的session，如何保证memcached本身的高可用性？<br>4.基于resin/tomcat web容器本身的session复制机制<br>5.基Redis缓存数据库进行session共享。<br>6.基于cookie进行session共享<br>分布式session是为了使web能适应大规模的访问。</p>
<h4 id="项目怎么实现的分布式session"><a href="#项目怎么实现的分布式session" class="headerlink" title="项目怎么实现的分布式session"></a>项目怎么实现的分布式session</h4><p>基于token/cookie的分布式会话（分布式session）实现<br>通过服务端把一个token写到cookie当中，然后客户端在随后的访问中携带这个cookie，服务端通过这个token就能找到相对应的用户。<br>登陆成功之后，给这个用户生成一个类似于session id的东西，比方说就叫token来标识这个用户然后写到cookie中，传递给客户端，客户端在随后的访问中，都在cookie中上传这个token服务端拿到这个token之后，用这个token来取用户对应的用户信息。</p>
<p>客户端禁用cookie时？<br>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。</p>
<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h3 id="秒杀逻辑的实现"><a href="#秒杀逻辑的实现" class="headerlink" title="秒杀逻辑的实现"></a>秒杀逻辑的实现</h3><p>秒杀——减库存、下订单、生成秒杀订单(一个全部的order，一个用于秒杀的miaosha_order)，三个操作一个事务</p>
<h4 id="超卖问题—在数据库层面解决"><a href="#超卖问题—在数据库层面解决" class="headerlink" title="超卖问题—在数据库层面解决"></a>超卖问题—在数据库层面解决</h4><p>1.秒杀商品的库存不允许为负数，sql语句中加一个where条件进行库存数量判断；<br>2.为miaosha_order建立一个唯一索引(userId，goodsId)，即一个用户只能秒杀一种商品的一个，防止用户重复购买。</p>
<h4 id="最后一件商品，多个用户同时抢购"><a href="#最后一件商品，多个用户同时抢购" class="headerlink" title="最后一件商品，多个用户同时抢购"></a>最后一件商品，多个用户同时抢购</h4><p>redis缓存中stock标识还剩1时，多个用户同时抢购，都拿到可以秒杀的标识，这些秒杀请求都放入消息队列中，但消息队列先进先出的顺序，第一个被消费者拿到的秒杀请求可以被处理成功，其后的秒杀请求在数据库层面都是<code>sql:where stock &lt; 0</code>，无法创建订单，秒杀失败。<br>redis预减库存是为了减少到达数据库层面的请求，实际到达数据库层面的请求也许会多于库存数量，但库存数量为零时的秒杀请求就返回失败。</p>
<h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h3 id="JMeter压测"><a href="#JMeter压测" class="headerlink" title="JMeter压测"></a>JMeter压测</h3><p>JMeter入门—自定义变量模拟多用户—JMeter命令行使用<br>Redis压测工具redis-benchmark</p>
<p>网站承载的并发：每秒查询率QPS<br>QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。<br>QPS = 并发量 / 平均响应时间，通常QPS用来表达和衡量当前系统的负载，也可以用RPS来表示。<br>TPS是LoadRunner中重要的性能参数指标。TPS每秒十五处理量。</p>
<p>压测时报这个错误org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation<br>经过面向google编程，发现可能出发这种异常情况的原因：<br>第一：请求contenttype=application/json;charset=UTF-8,而这里的produces=text/html原来代码：@RequestMapping(value = “/upload”, method = RequestMethod.POST, produces = “text/html; charset=UTF-8”)解决方法：去掉produces = “text/html; charset=UTF-8”这段代码或者设置produces=application/json;charset=UTF-8<br>第二：方法名重复例子：① html的名字   showArticle.html② js的名字   showArticle.js③ajax传到后台来执行的方法名   ajax的url:”showArticle”④后台拦截方法名@ResponseBody@RequestMapping(value = “/showArticle”, method = RequestMethod.POST)解决方案防止静态文件名跟控制器请求路由冲突。如本例中，将login.html更名为signin.html。将静态文件URI与动态请求URI分离。如，把提供REST接口的URI都改成以/api/XXX开头，把静态文件改为以/static/XXX开头。这样当请求/static/login.html时，spring会直接使用内置的处理静态资源的控制器返回静态文件而不再去查找用户定义的控制器。</p>
<h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>缓存逻辑<br>1.失效：应用程序先从缓存取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。<br>2.命中：应用程序从缓存中取数据，取到后返回。<br>3.更新：先把数据存到数据库中，成功后，再让缓存失效，更新缓存。不能先删除缓存，再更新数据库，会导致缓存数据不一致。<br>4.缓存处理流程：前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。</p>
<h3 id="缓存穿透和缓存雪崩"><a href="#缓存穿透和缓存雪崩" class="headerlink" title="缓存穿透和缓存雪崩"></a>缓存穿透和缓存雪崩</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透(缓存和数据库中都没有的数据)是指查询一个缓存中一定不存在数据，由于缓存不命中，接着查询数据库也无法查询出结果，因此也不会写入到缓存中，这将会导致每个查询都会去请求数据库。<br>解决方案：<br>1.布隆过滤。<br>对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免对底层存储系统的查询压力。<br>比如，接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；<br>2.缓存空对象。<br>当存储层中没有结果后，即使返回的空对象也将其存储起来(key：null)，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。（问题是，一、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；二、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响）。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿，是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这是由于并发用户特别多，同时读缓存没读到数据(并发查询同一条数据)，又同时去数据库去数据，引起数据库压力瞬间增大，造成过大压力。<br>解决方案：<br>1.设置热点数据，永远不过期<br>2.加互斥锁。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指，由于缓存层承载着大量的请求，有效地保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会到达存储层，存储层的调用量会暴增，造成存储层数据库会挂掉。<br>解决方案：<br>1.依赖隔离组件为后端限流并降级。在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某一个key只允许一个线程查询数据和写缓存，其他线程等待。<br>2.数据预热。可以通过缓存reload机制，预先去更新缓存，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。<br>3.设置热点数据，不过期。</p>
<h4 id="缓存并发"><a href="#缓存并发" class="headerlink" title="缓存并发"></a>缓存并发</h4><p>缓存并发是指，高并发场景下同时大量查询过期的key值，最后查询数据库将缓存结果回写到缓存，造成数据库压力过大。<br>解决方案：<br>分布式锁。在缓存更新或者过期的情况下，先获取锁，在进行更新或者从数据库中获取数据后，再释放锁，需要一定的时间等待，就可以从缓存中继续获取数据。</p>
<h3 id="页面优化"><a href="#页面优化" class="headerlink" title="页面优化"></a>页面优化</h3><h4 id="1-页面缓存-URL缓存-对象缓存"><a href="#1-页面缓存-URL缓存-对象缓存" class="headerlink" title="1.页面缓存(+URL缓存)+对象缓存"></a>1.页面缓存(+URL缓存)+对象缓存</h4><p>页面缓存：访问一个页面时，首先不是让我们的系统去渲染页面(页面的html和css)，而是先从缓存中取，如果找到了就直接返回给客户端，如果没有就手动渲染再将结果返回给客户端，同时把结果存储到缓存，下次可以直接使用。<br>URL缓存与页面缓存实际上一样，url中多了一个id参数，根据id去取相应的事物的缓存内容。<br>对象缓存：设置token，返回一个对象。</p>
<h4 id="2-页面静态化，前后端分离。"><a href="#2-页面静态化，前后端分离。" class="headerlink" title="2.页面静态化，前后端分离。"></a>2.页面静态化，前后端分离。</h4><p> 页面静态化，不用JSP，用html写页面，用js和ajax获取/提交数据、渲染页面，实现前后端分离。<br> 页面静态化将页面缓存到用户的浏览器，用户访问页面时，不需要与服务端交互，从本地缓存拿到页面，节省流量。<br> 应用：将活动页面上(秒杀商品页面和商品列表)的所有可以静态的元素全部静态化，尽量减少动态元素，将静态页面缓存到redis中，访问秒杀商品页面时首先不是让系统去渲染页面而是先从缓存中取。</p>
<h4 id="3-静态资源优化"><a href="#3-静态资源优化" class="headerlink" title="3.静态资源优化"></a>3.静态资源优化</h4><p>1.JS/CSS压缩，自动去除空白字符和注释减小页面的体积，减少流量<br>2.多个JS/CSS的访问请求组合到一个请求中，减少连接数</p>
<h4 id="4-CDN优化"><a href="#4-CDN优化" class="headerlink" title="4.CDN优化"></a>4.CDN优化</h4><p>CDN内容分发网络Content Delivery Network。<br>CDN就近访问。</p>
<h4 id="高并发问题的解决"><a href="#高并发问题的解决" class="headerlink" title="高并发问题的解决"></a>高并发问题的解决</h4><p>瓶颈在数据库，加缓存来解决。从用户发起请求的时候，从浏览器开始，做页面的静态化将页面缓存到用户的浏览器端，在请求到达网站之前，部署一些CDN请求结点，让请求先访问CDN，（中间还可以有一层Nginx缓存），再做应用程序的页面缓存(将页面代码缓存到redis)，下一层对象缓存(将java对象缓存到redis)，最后访问数据库。一层一层的缓存来削减最后到达数据库的请求数量，保证网站在高并发情况下抗住压力。<br>采用缓存不可避免会导致数据的不一致。</p>
<h3 id="第六章接口优化"><a href="#第六章接口优化" class="headerlink" title="第六章接口优化"></a>第六章接口优化</h3><p>1.Redis预减库存减少数据库访问<br>思路：减少数据库访问<br>1）系统初始化，把商品库存数量加载到redis<br>2）收到用户秒杀请求，redis预减库存，库存不足的时候，直接返回秒杀失败，这样后面的请求对数据库的压力就没有了，否则进入3<br>3）将秒杀请求放入消息队列，返回用户一个响应“排队中”，此时还没有立即对数据库进行操作，而是进行异步下单<br>4）这时客户端会询问是否秒杀成功；服务端的队列将请求出队，生成订单，减少库存，给客户端秒杀成功的响应。<br>2.内存标记减少Redis访问<br>3.请求先入队(队列RabbitMQ)缓冲，异步下单，增强用户体验<br>4.<strong>Nginx水平/横向扩展</strong><br>用Nginx做一个反向代理，将本机80端口收到的请求反向代理，交给服务器集群(server_pool)，让这些服务器的权重weight相同，均分请求，负载均衡。<br><img src="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/nginx.png"><br><img src="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/jiagou.png"><br>5.数据库分库分表 中间件mycat</p>
<h4 id="思路：减少数据库访问"><a href="#思路：减少数据库访问" class="headerlink" title="思路：减少数据库访问"></a>思路：减少数据库访问</h4><p>1.系统初始化，把商品库存数量加载到Redis<br>2.收到请求，Redis预减库存，库存不足，直接返回秒杀失败，否则进入3<br>3.请求入队，立即返回排队中<br>4.请求出队，生成订单，减少库存<br>5.客户端轮询，是否秒杀成功</p>
<h4 id="轮询的实现"><a href="#轮询的实现" class="headerlink" title="轮询的实现"></a>轮询的实现</h4><p>setTimeout(getMiaoshaResult(), 200); 延时执行函数</p>
<h4 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h4><p>5000个线程 访问10次 50000个请求 QPS：2114</p>
<h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>1.秒杀接口地址隐藏<br>思路：秒杀开始之前不知道秒杀的地址，不是写死的，要从服务端获取，动态拼成。<br>秒杀开始之前，先去秒杀请求接口获取秒杀地址。<br>1）接口改造，带上PathVariable参数<br>2）添加生成地址的接口<br>3）秒杀收到请求，先验证PathVariable参数</p>
<p>2.数学公式验证码—通过验证码来保证获取秒杀接口的地址的安全<br>思路：点击秒杀之前，先输入验证码，分散用户的请求。<br>作用：1）防止机器人盗刷；2）让用户填写验证码，让请求不会非常集中，将瞬间的并发量分散开，减轻数据库的压力。<br>实现：1）添加生成验证码的接口；2）在获取秒杀路径的时候，验证验证码；3）ScriptEngine使用。</p>
<p>3.接口限流防刷<br>限制同一UserID访问频率。<br>第一种：限制用户访问在一段时间之内只能访问有限的次数，超过这个次数就认为它是非法的。<br>做计时器，在用户访问的时候，记录他的访问次数。这个是在缓存中实现，比如说限定时间是一分钟可以允许用户访问接口100次，用户拿到秒杀地址后就开始计数，1分钟内访问次数就加一，超过有效期并且用户访问次数没有超过限制就重置，归零重新计数。<br>第二种：禁止重复提交，用户提交之后按钮置灰。IP限流。</p>
<p>get和post有什么区别？<br>GET是幂等的,从服务端获取数据,不会使服务端的数据产生变化<br>POST向服务端提交数据,要使得服务端的数据发生变化</p>
<h3 id="起竖机构态势信息高效表示及识别的研究"><a href="#起竖机构态势信息高效表示及识别的研究" class="headerlink" title="起竖机构态势信息高效表示及识别的研究"></a>起竖机构态势信息高效表示及识别的研究</h3><p>1.研究背景<br>在起竖控制系统中，执行终端误差表示属于一类技术矛盾：一个系统中两种需求之间的矛盾，即控制精度需求(要求误差等级划分尽量详细)与计算代价(要求误差等级划分尽量少)之间的矛盾，为其中之一而优化参数将导致另一项指标的恶化。<br>采用二值逻辑真或假来表示某一等级当前是或不是有效信息，控制器可以同时接收系统误差的所有可能状态，就是一组0、1组成的数串，该数串中至多有一位为1，即至多有一个误差等级是有效的。<br>当提高系统对误差的灵敏度、细化误差等级划分时，误差等级数目增加，误差等级数串的位数也将随之呈线性增加趋势，势必增加传输和暂存代价。控制系统进行决策计算时，误差等级数串最终要落实到硬件计算单元被处理。当误差等级数目增加进而导致数串的位数增加时，必然要相应改变误差等级信息的传输及计算的硬件单元数据线宽度，这将为改进系统控制性能带来不便。<br>2.选用Hamming编码<br>因此，将起竖机构执行终端误差表示中的矛盾依据TRIZ理论(发明问题解决理论)归纳的通用工程参数概括为信息数量与信息损失。<br>基于发明原理15“动态化“原理解决改善信息数量的同时造成信息损失的问题，将固定的信息表示方式改为可变的表示方式，即对执行终端误差信息进行编码，并选择Hamming规则进行编码。<br>应用Hamming编码方法对态势信息进行编码<br>Hamming码由美国数学家Richard Wesley Hamming提出，通过在传输的消息流中插入验证码的方法，侦测并更正单一bit错误，hamming码只能检测到一位错误。<br>在数据校验与纠错应用中，传输的对象是Hamming码的全部码位，确定错误码位后需要直接纠错该码位。在本次研究的起竖机构控制系统的误差表示应用中，误差信息数串中的码位必须是系统实时误差等级的真实反应，不能通过数值计算直接修改，而是由协同核心启用决策状态转移函数进行输出模式的计算，而且误差状态字已经能够反应误差等级数串的信息，因此，在检测误差时只需要传输误差状态字即可，不需传输Hamming码的全部码位。</p>
<h4 id="应用Hamming编码规则表示输出回路的角度跟踪误差"><a href="#应用Hamming编码规则表示输出回路的角度跟踪误差" class="headerlink" title="应用Hamming编码规则表示输出回路的角度跟踪误差"></a>应用Hamming编码规则表示输出回路的角度跟踪误差</h4><p>应用已有的文献，依托前人推导的Hamming规则的依据，建立的二叉树结构的Hamming树，使基于繁琐逻辑运算的Hamming校验过程可以被从根节点按路径权值访问叶节点的方式取代，这样来确定出错码位。</p>
<p>计算海明码的位数：假设用N表示加入了校验码位后整个传输信息的二进制位数。用K代表当中有效信息位数，r表示加入的校验码位数，它们之间的关系应满足：N=K＋r≤2r－1（是为了确保r位校验码能校验所有的数据位，由于r位校验码所能表示的最大十进制数为2r-1，同一时候也确保各位码本身不被其它校验码校验）<br>|  信息码位数  | 1 | 2-4 | 5-11 | 12-26 | 27-57 | 57-120 | 121-247 |<br>| ————|—|—–|——|——-|——-|——–|———|<br>|  校验码位数  | 2 | 3   |   4  |   5   |   6   |    7   |    8    |</p>
<p>根据数据的码位和海明码以某种规则进行运算，异或再相加，得到的结果判断该码位是否出错。</p>
<p>1.海明码检错/纠错基本思想<br>（1）将有效信息按某种规律分成若干组，每组安排一个校验位通过异或运算进行校验，得出具体的校验码<br>（2）在接收端同样通过异或运算看各组校验结果是否正确，并观察出错的校校组，或者多个出错的校验组的共同校验位，得出具体的出错比特位<br>（3）对错误位取反来将其纠正</p>
<p>2.海明码计算<br>(1) 计算校验码位数<br>(2) 确定校验码位置<br>(3) 确定校验码<br> 校验位置选择原则：第i位校验码从当前校验码位开始，每次连续校验i位后再跳过i位，然后再连续校验i位，再跳过i位，以此类推。确定每个校验码所校验的比特位：<br>P1校验码位校验的码字位为：第1位（也就是P1本身）、第3位、第5位、第7位、第9位、第11位、第13位、第15位，……。<br>P2校验码位校验的码字位为：第2位（也就是P2本身）、第3位，第6位、第7位，第10位、第11位，第14位、第15位，……。<br>P3校验码位校验的码字位为：第4位（也就是P4本身）、第5位、第6位、第7位，第12位、第13位、第14位、第15位，第20位、第21位、第22位、第23位，……。<br>Pn校验码位校验的码字位为：第2n-1位（也就是Pn本身）、第2n-1+1位、第2n-1+2位、第2n-1+3位、……、第2n-1位，第3×2n-1位、第3×2n-1+1、……、第2×2n-1位，第5×2n-1位、第5×2n-1+1位、第3×2n-1位，……、第7×2n-1位、第7×2n-1+1位、……、第4×2n-1位，……，第(2m-1) 2n-1位、……第m×2n-1位<br>    最后每组通过异或逻辑运算（与偶校验原理一样），使每组的运算结果为0(偶校验)，即可得出第i位校验码的值。<br>(4)实现检错<br>码字中的信息码位同时被多个校验码进行校验，然后通过这些码位对不同校验码的联动影响最终可以找出是哪一位出错了。<br>所有校验码所在的位是只由对应的校验码进行校验，如第1位（只由p1校验）、第2位（只由p2校验）、第4位（只由p3校验）、第8位（只由p4校验）、第16位（只由p5校验），……。也就是这些位如果发生了差错，影响的只是对应的校验码的校验结果，不会影响其它校验码的校验结果。这点很重要，如果最终发现只是一个校验组中的校验结果不符，则直接可以知道是对应校验组中的校验码在传输过程中出现了差错。<br>所有信息码位均被至少两个校验码进行了校验，也就是至少校验了两次。查看对应的是哪两组校验结果不符，确定是哪位信息码在传输过程中出了差错。<br>海明码校验的方式就是各校验码对它所校验的位组进行“异或运算”.<br>校验位组如下图示：<br><img src="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/haimingmajiaoyanweizu.png"><br>正常情况下（也就是整个码字不发生差错的情况下），在采用偶校验时，各校验组通过异或运算后的校验结果均应该是为0，也就是前面所说的G1、G2、G3、G4，……均为0，因为此时1为偶数个，进行异或运算后就是0；而采用奇校验时，各组校验结果均应是为1。<br>(5)纠错<br>检测出了是哪位差错还不够，因为海明码具有纠正一位错误的能力，所以还需要完成纠错过程。这个过程的原理比较简单，就是直接对错误的位进行取反，或者加“1”操作，使它的值由原来的“1”变成“0”，由原来的“0”变成“1”（因为二进制中每一位只能是这二者之一）。</p>
</div><div class="tags"><a href="/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"><i class="fa fa-tag"></i>秒杀系统</a></div><div class="post-nav"><a class="pre" href="/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">Linux常用命令总结</a><a class="next" href="/2019/07/24/MySQL/">数据库知识——mysql相关</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'NPvQJfh7XNHqMqbmVYOg5VE5-9Nh9j0Va',
  appKey:'hgOdKtBYlsJzigDKoXqevrSI',
  placeholder:'我想听你说一句… （留言请填写您的昵称和邮箱，方便回复以邮件形式通知您）',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://blog.frozenwind.online"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/emotion/">emotion</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/IDE%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">IDE插件</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">Java并发和多线程</a> <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">java基础</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/Nexus/" style="font-size: 15px;">Nexus</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/" style="font-size: 15px;">分布式ID</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 15px;">分布式事务</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" style="font-size: 15px;">分布式缓存</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 15px;">分布式锁</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" style="font-size: 15px;">工作问题记录</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">操作系统</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">微信小程序</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/%E6%83%85%E4%B9%A6/" style="font-size: 15px;">情书</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/%E6%B8%AF%E4%B9%90/" style="font-size: 15px;">港乐</a> <a href="/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">秒杀系统</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%AF%8D/" style="font-size: 15px;">词</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">随笔</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/09/21/Java%E6%BA%90%E7%A0%81-ConcurrentHashMap/">Java源码-ConcurrentHashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/">Java并发和多线程-线程池在业务中的实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Java并发和多线程-线程池ThreadPoolExecutor</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/05/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">实际开发中遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/31/SpringBoot-Tomcat/">SpringBoot-Tomcat</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/31/Tomcat/">Tomcat</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Apache%20Pulsar/">消息队列——Apache Pulsar</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/">消息队列——Kafka</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/">Java并发和多线程-介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/05/IDE%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-vscode/">IDE插件开发-VS Code</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>